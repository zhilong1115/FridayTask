<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>2026-02-04 - Agent Planning: ä»»åŠ¡åˆ†è§£ä¸è§„åˆ’ç­–ç•¥</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; line-height: 1.7; }
    .bilingual { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .zh { border-left: 3px solid #f9ab00; padding-left: 15px; }
    .en { border-left: 3px solid #1a73e8; padding-left: 15px; }
    h1 { color: #3c4043; border-bottom: 2px solid #f9ab00; padding-bottom: 10px; }
    h2 { color: #1a73e8; margin-top: 30px; }
    h3 { color: #5f6368; }
    .architecture { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; }
    pre { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 13px; }
    code { font-family: 'SF Mono', Monaco, monospace; }
    .highlight { background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .highlight-blue { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .highlight-green { background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .diagram { background: #fafafa; padding: 20px; border-radius: 8px; margin: 20px 0; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; white-space: pre; overflow-x: auto; }
    .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
    .comparison > div { padding: 15px; border-radius: 8px; }
    .pattern-a { background: #fff3e0; border: 2px solid #ff9800; }
    .pattern-b { background: #e8f5e9; border: 2px solid #4caf50; }
    .interview { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin: 25px 0; }
    .interview h3 { color: white; margin-top: 0; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { border: 1px solid #dadce0; padding: 10px; text-align: left; }
    th { background: #f8f9fa; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px; }
    .tag-hot { background: #ff5722; color: white; }
    .tag-interview { background: #9c27b0; color: white; }
    .tag-practical { background: #4caf50; color: white; }
    .series-nav { background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
    .series-nav a { color: #1a73e8; text-decoration: none; margin-right: 15px; }
    .series-nav .current { font-weight: bold; color: #f9ab00; }
  </style>
</head>
<body>
  <div class="series-nav">
    <strong>ğŸ¤– Agent ç³»åˆ—ï¼š</strong>
    <a href="2026-02-01-react-pattern-tool-use.html">Day 1: ReAct</a>
    <a href="2026-02-02-multi-agent-collaboration.html">Day 2: Multi-Agent</a>
    <a href="2026-02-03-agent-memory-design.html">Day 3: Memory</a>
    <span class="current">Day 4: Planning â† ä»Šå¤©</span>
  </div>

  <h1>ğŸ§  Agent Planning: ä»»åŠ¡åˆ†è§£ä¸è§„åˆ’ç­–ç•¥</h1>
  <p>
    <span class="tag tag-interview">é¢è¯•çƒ­ç‚¹</span>
    <span class="tag tag-practical">å®ç”¨å¼€å‘</span>
    <span class="tag tag-hot">Agent æ ¸å¿ƒ</span>
    <br><br>
    Agent ç³»åˆ—å®Œç»“ç¯‡ | ğŸ“… 2026-02-04
  </p>

  <h2>ğŸ“– æ¦‚è¿° / Overview</h2>
  <div class="bilingual">
    <div class="zh">
      <p><strong>Planningï¼ˆè§„åˆ’ï¼‰</strong>æ˜¯ Agent çš„"å¤§è„‘"â€”â€”å†³å®šå¦‚ä½•æŠŠå¤æ‚ä»»åŠ¡æ‹†è§£æˆå¯æ‰§è¡Œçš„æ­¥éª¤ã€‚</p>
      <p>å¥½çš„è§„åˆ’èƒ½åŠ›æ˜¯ Claude Codeã€Codex CLI ç­‰ coding agent æˆåŠŸçš„å…³é”®ã€‚å·®çš„è§„åˆ’ä¼šå¯¼è‡´ï¼š</p>
      <ul>
        <li>æ— é™å¾ªç¯ï¼Œé‡å¤å°è¯•åŒæ ·çš„å¤±è´¥æ–¹æ³•</li>
        <li>é—æ¼å…³é”®æ­¥éª¤ï¼Œæœ€ç»ˆæ— æ³•å®Œæˆä»»åŠ¡</li>
        <li>Token æµªè´¹ï¼Œæˆæœ¬çˆ†ç‚¸</li>
      </ul>
      <p>ä»Šå¤©è®² 4 ç§ä¸»æµè§„åˆ’ç­–ç•¥ + é¢è¯•æ€ä¹ˆç­”ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Planning</strong> is the "brain" of an Agent â€” deciding how to decompose complex tasks into executable steps.</p>
      <p>Good planning is key to the success of coding agents like Claude Code and Codex CLI. Poor planning leads to:</p>
      <ul>
        <li>Infinite loops, repeatedly trying failed approaches</li>
        <li>Missing critical steps, failing to complete tasks</li>
        <li>Token waste, cost explosion</li>
      </ul>
      <p>Today: 4 mainstream planning strategies + interview tips.</p>
    </div>
  </div>

  <h2>ğŸ—ï¸ è§„åˆ’ç­–ç•¥å…¨æ™¯å›¾ / Planning Strategies Overview</h2>
  
  <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Agent Planning Strategies                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1. Plan-and-     â”‚    â”‚ 2. ReWOO         â”‚    â”‚ 3. Tree of       â”‚  â”‚
â”‚  â”‚    Execute       â”‚    â”‚                   â”‚    â”‚    Thoughts      â”‚  â”‚
â”‚  â”‚                   â”‚    â”‚                   â”‚    â”‚                   â”‚  â”‚
â”‚  â”‚ Plan â†’ Execute   â”‚    â”‚ Plan all steps   â”‚    â”‚ Explore multiple â”‚  â”‚
â”‚  â”‚ â†’ Observe        â”‚    â”‚ BEFORE any       â”‚    â”‚ reasoning paths  â”‚  â”‚
â”‚  â”‚ â†’ Re-plan        â”‚    â”‚ execution        â”‚    â”‚ in parallel      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â†“                        â†“                        â†“             â”‚
â”‚   [Flexible]              [Efficient]              [Thorough]          â”‚
â”‚   Most common             Fewer LLM calls          Complex reasoning   â”‚
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚ 4. Hierarchical  â”‚    â”‚ 5. Reflection    â”‚                          â”‚
â”‚  â”‚    Planning      â”‚    â”‚    + Re-plan     â”‚                          â”‚
â”‚  â”‚                   â”‚    â”‚                   â”‚                          â”‚
â”‚  â”‚ High-level plan  â”‚    â”‚ Execute â†’ Check  â”‚                          â”‚
â”‚  â”‚ â†’ Sub-plans      â”‚    â”‚ â†’ Fix mistakes   â”‚                          â”‚
â”‚  â”‚ â†’ Micro-tasks    â”‚    â”‚ â†’ Re-plan        â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚         â†“                        â†“                                      â”‚
â”‚   [Scalable]              [Robust]                                     â”‚
â”‚   Long-horizon tasks      Self-correction                              â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <h2>1ï¸âƒ£ Plan-and-Execute æ¨¡å¼</h2>
  <div class="highlight">
    <strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong>å…ˆåˆ¶å®šè®¡åˆ’ï¼Œè¾¹æ‰§è¡Œè¾¹è°ƒæ•´
  </div>

  <div class="bilingual">
    <div class="zh">
      <p><strong>æœ€å¸¸ç”¨çš„æ¨¡å¼</strong>ï¼ŒLangGraph å®˜æ–¹æ¨èã€‚åˆ†ä¸¤ä¸ª Agentï¼š</p>
      <ol>
        <li><strong>Planner</strong>: åˆ¶å®šé«˜å±‚è®¡åˆ’ï¼ˆæ­¥éª¤åˆ—è¡¨ï¼‰</li>
        <li><strong>Executor</strong>: æ‰§è¡Œå•ä¸ªæ­¥éª¤ï¼ˆå¯ä»¥æ˜¯ ReAct Agentï¼‰</li>
      </ol>
      <p>æ‰§è¡Œæ¯ä¸€æ­¥åï¼ŒPlanner å¯ä»¥æ ¹æ®ç»“æœ<strong>é‡æ–°è§„åˆ’</strong>å‰©ä½™æ­¥éª¤ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Most common pattern</strong>, officially recommended by LangGraph. Two agents:</p>
      <ol>
        <li><strong>Planner</strong>: Creates high-level plan (list of steps)</li>
        <li><strong>Executor</strong>: Executes single step (can be ReAct agent)</li>
      </ol>
      <p>After each step, Planner can <strong>re-plan</strong> remaining steps based on results.</p>
    </div>
  </div>

  <div class="diagram">
Plan-and-Execute Flow:

User Task: "Add user authentication to the Flask app"
                    â”‚
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     PLANNER       â”‚
        â”‚                   â”‚
        â”‚  "Let me break    â”‚
        â”‚   this down..."   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Plan:                       â”‚
    â”‚ 1. Check current structure  â”‚
    â”‚ 2. Install Flask-Login      â”‚
    â”‚ 3. Create User model        â”‚
    â”‚ 4. Add login routes         â”‚
    â”‚ 5. Add session middleware   â”‚
    â”‚ 6. Test authentication      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚
        â–¼                   â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
  â”‚ EXECUTOR â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  Step 1  â”‚              â”‚
  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â”‚
       â”‚                    â”‚
       â–¼                    â”‚
  [Result: Found            â”‚
   SQLAlchemy ORM]          â”‚
       â”‚                    â”‚
       â–¼                    â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
  â”‚ PLANNER  â”‚              â”‚
  â”‚ Re-plan? â”‚â”€â”€â”€â”€ No â”€â”€â”€â”€â”€â”€â”¤
  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜              â”‚
       â”‚ Yes (if needed)    â”‚
       â–¼                    â”‚
  [Updated Plan:            â”‚
   Step 3 â†’ Use existing    â”‚
   SQLAlchemy models]       â”‚
       â”‚                    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             (loop)
  </div>

  <h3>ğŸ’» TypeScript å®ç°</h3>
  <pre><code>interface Plan {
  steps: string[];
  currentStep: number;
}

interface ExecutionResult {
  success: boolean;
  output: string;
  observation: string;
}

class PlanAndExecuteAgent {
  private planner: LLM;
  private executor: ReActAgent;
  
  async run(task: string): Promise<string> {
    // Step 1: Create initial plan
    let plan = await this.createPlan(task);
    console.log("ğŸ“‹ Initial Plan:", plan.steps);
    
    const results: ExecutionResult[] = [];
    
    // Step 2: Execute each step with potential re-planning
    while (plan.currentStep < plan.steps.length) {
      const step = plan.steps[plan.currentStep];
      console.log(`\nğŸ”„ Executing Step ${plan.currentStep + 1}: ${step}`);
      
      // Execute current step (using ReAct agent)
      const result = await this.executor.run(step);
      results.push(result);
      
      // Check if we need to re-plan
      if (!result.success || this.shouldReplan(result, plan)) {
        console.log("ğŸ”„ Re-planning based on results...");
        plan = await this.replan(task, plan, results);
      } else {
        plan.currentStep++;
      }
    }
    
    return this.synthesizeResults(results);
  }
  
  private async createPlan(task: string): Promise<Plan> {
    const response = await this.planner.complete({
      system: `You are a planning agent. Break down the task into clear, 
               actionable steps. Return JSON: { "steps": ["step1", "step2", ...] }`,
      user: task
    });
    
    const { steps } = JSON.parse(response);
    return { steps, currentStep: 0 };
  }
  
  private async replan(
    originalTask: string, 
    currentPlan: Plan, 
    results: ExecutionResult[]
  ): Promise<Plan> {
    const context = `
Original task: ${originalTask}
Original plan: ${JSON.stringify(currentPlan.steps)}
Completed steps: ${currentPlan.currentStep}
Results so far: ${JSON.stringify(results)}

Based on these results, create an updated plan for remaining work.
`;
    
    const response = await this.planner.complete({
      system: "Update the plan based on execution results. Return JSON: { steps: [...] }",
      user: context
    });
    
    const { steps } = JSON.parse(response);
    return { steps, currentStep: 0 };
  }
  
  private shouldReplan(result: ExecutionResult, plan: Plan): boolean {
    // Re-plan triggers:
    // 1. Step failed
    // 2. Discovered new information that changes approach
    // 3. Found a shortcut
    return !result.success || 
           result.observation.includes("ERROR") ||
           result.observation.includes("alternative approach");
  }
}</code></pre>

  <h2>2ï¸âƒ£ ReWOO (Reasoning WithOut Observation)</h2>
  <div class="highlight-blue">
    <strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong>å…ˆè§„åˆ’æ‰€æœ‰æ­¥éª¤å’Œå·¥å…·è°ƒç”¨ï¼Œç„¶åæ‰¹é‡æ‰§è¡Œï¼ˆå‡å°‘ LLM è°ƒç”¨æ¬¡æ•°ï¼‰
  </div>

  <div class="bilingual">
    <div class="zh">
      <p><strong>å…³é”®ä¼˜åŠ¿ï¼š</strong>Token æ•ˆç‡æé«˜ã€‚ä¼ ç»Ÿ ReAct æ¯ä¸€æ­¥éƒ½è¦è°ƒç”¨ LLMï¼ŒReWOO åªè°ƒç”¨ 2-3 æ¬¡ã€‚</p>
      <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong></p>
      <ul>
        <li>æ­¥éª¤ä¹‹é—´ç›¸å¯¹ç‹¬ç«‹</li>
        <li>ä¸éœ€è¦æ ¹æ®ä¸­é—´ç»“æœå¤§å¹…è°ƒæ•´è®¡åˆ’</li>
        <li>å¯¹æˆæœ¬æ•æ„Ÿçš„åº”ç”¨</li>
      </ul>
      <p><strong>ç¼ºç‚¹ï¼š</strong>ä¸å¤Ÿçµæ´»ï¼Œå¦‚æœæ—©æœŸæ­¥éª¤å¤±è´¥ï¼Œåç»­è®¡åˆ’å¯èƒ½æ— æ•ˆã€‚</p>
    </div>
    <div class="en">
      <p><strong>Key advantage:</strong> Extremely token-efficient. Traditional ReAct calls LLM every step; ReWOO only 2-3 times.</p>
      <p><strong>Use cases:</strong></p>
      <ul>
        <li>Steps are relatively independent</li>
        <li>No need to drastically adjust plan based on intermediate results</li>
        <li>Cost-sensitive applications</li>
      </ul>
      <p><strong>Downside:</strong> Less flexible â€” if early steps fail, later plans may be invalid.</p>
    </div>
  </div>

  <div class="diagram">
ReWOO vs ReAct Comparison:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ReAct (Traditional)                                                      â”‚
â”‚                                                                          â”‚
â”‚ LLM â†’ Tool â†’ LLM â†’ Tool â†’ LLM â†’ Tool â†’ LLM â†’ Answer                     â”‚
â”‚  â”‚           â”‚           â”‚           â”‚                                  â”‚
â”‚  â–¼           â–¼           â–¼           â–¼                                  â”‚
â”‚ [4 LLM calls, interleaved with tool execution]                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ReWOO (Efficient)                                                        â”‚
â”‚                                                                          â”‚
â”‚ LLM (Plan all) â†’ Tool â†’ Tool â†’ Tool â†’ LLM (Synthesize) â†’ Answer         â”‚
â”‚       â”‚                                      â”‚                          â”‚
â”‚       â–¼                                      â–¼                          â”‚
â”‚ [Only 2 LLM calls! Plan first, execute all, then synthesize]            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <h3>ğŸ’» ReWOO å®ç°</h3>
  <pre><code>interface ReWOOPlan {
  steps: {
    id: string;
    tool: string;
    args: Record<string, any>;
    dependsOn: string[];  // Variable references like #E1, #E2
  }[];
}

class ReWOOAgent {
  async run(task: string): Promise<string> {
    // Step 1: Plan ALL steps upfront (single LLM call)
    const plan = await this.planAllSteps(task);
    
    // Step 2: Execute all steps, substituting variables
    const evidence: Record<string, string> = {};
    
    for (const step of plan.steps) {
      // Replace variable references with actual evidence
      const resolvedArgs = this.resolveVariables(step.args, evidence);
      
      // Execute tool
      const result = await this.executeTool(step.tool, resolvedArgs);
      evidence[step.id] = result;
      
      console.log(`âœ… ${step.id}: ${result.substring(0, 100)}...`);
    }
    
    // Step 3: Synthesize final answer (single LLM call)
    return this.synthesize(task, evidence);
  }
  
  private async planAllSteps(task: string): Promise<ReWOOPlan> {
    const response = await this.llm.complete({
      system: `Plan all steps needed to complete the task.
Use #E1, #E2, etc. as variable placeholders for step outputs.

Example format:
{
  "steps": [
    { "id": "E1", "tool": "search", "args": { "query": "..." }, "dependsOn": [] },
    { "id": "E2", "tool": "fetch", "args": { "url": "#E1.url" }, "dependsOn": ["E1"] },
    { "id": "E3", "tool": "summarize", "args": { "text": "#E2" }, "dependsOn": ["E2"] }
  ]
}`,
      user: task
    });
    
    return JSON.parse(response);
  }
  
  private resolveVariables(
    args: Record<string, any>, 
    evidence: Record<string, string>
  ): Record<string, any> {
    const resolved = { ...args };
    
    for (const [key, value] of Object.entries(resolved)) {
      if (typeof value === 'string' && value.startsWith('#E')) {
        // Replace #E1, #E2.field, etc. with actual values
        const match = value.match(/#(E\d+)(\.(\w+))?/);
        if (match) {
          const [, varId, , field] = match;
          let replacement = evidence[varId];
          if (field && replacement) {
            replacement = JSON.parse(replacement)[field];
          }
          resolved[key] = replacement;
        }
      }
    }
    
    return resolved;
  }
}</code></pre>

  <h2>3ï¸âƒ£ Tree of Thoughts (ToT)</h2>
  <div class="highlight-green">
    <strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong>æ¢ç´¢å¤šæ¡æ¨ç†è·¯å¾„ï¼Œé€‰æ‹©æœ€ä¼˜è§£ï¼ˆé€‚åˆå¤æ‚é—®é¢˜ï¼‰
  </div>

  <div class="bilingual">
    <div class="zh">
      <p><strong>çµæ„Ÿæ¥æºï¼š</strong>äººç±»è§£å†³å¤æ‚é—®é¢˜æ—¶ï¼Œä¼šè€ƒè™‘å¤šç§å¯èƒ½æ€§ï¼Œè€Œä¸æ˜¯ä¸€æ¡è·¯èµ°åˆ°é»‘ã€‚</p>
      <p><strong>ä¸‰ä¸ªå…³é”®ç»„ä»¶ï¼š</strong></p>
      <ol>
        <li><strong>Thought Generator</strong>: ç”Ÿæˆå¤šä¸ªå¯èƒ½çš„ä¸‹ä¸€æ­¥</li>
        <li><strong>State Evaluator</strong>: è¯„ä¼°æ¯ä¸ªçŠ¶æ€çš„å‰æ™¯</li>
        <li><strong>Search Algorithm</strong>: BFS/DFS éå†æ€ç»´æ ‘</li>
      </ol>
      <p><strong>é€‚ç”¨åœºæ™¯ï¼š</strong>æ•°å­¦è¯æ˜ã€ä»£ç  debugã€ç­–ç•¥æ¸¸æˆã€åˆ›æ„å†™ä½œ</p>
    </div>
    <div class="en">
      <p><strong>Inspiration:</strong> Humans explore multiple possibilities when solving complex problems, not just one path.</p>
      <p><strong>Three key components:</strong></p>
      <ol>
        <li><strong>Thought Generator</strong>: Generate multiple possible next steps</li>
        <li><strong>State Evaluator</strong>: Evaluate the promise of each state</li>
        <li><strong>Search Algorithm</strong>: BFS/DFS to traverse thought tree</li>
      </ol>
      <p><strong>Use cases:</strong> Math proofs, code debugging, strategy games, creative writing</p>
    </div>
  </div>

  <div class="diagram">
Tree of Thoughts Structure:

                        [Initial Problem]
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚               â”‚               â”‚
              â–¼               â–¼               â–¼
         [Approach A]    [Approach B]    [Approach C]
         Score: 0.7      Score: 0.9      Score: 0.4
              â”‚               â”‚               âœ— (pruned)
              â”‚               â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
     â”‚                 â”‚     â”‚
     â–¼                 â–¼     â–¼
  [A.1]             [A.2] [B.1] â† Best path
  Score: 0.5       Score: 0.6  Score: 0.95
     âœ—                â”‚        â”‚
                      â”‚        â”‚
                      â–¼        â–¼
                   [A.2.1]  [B.1.1] â† Solution!
                   Score: 0.7  Score: 0.98
  </div>

  <h3>ğŸ’» Tree of Thoughts å®ç°</h3>
  <pre><code>interface ThoughtNode {
  state: string;
  thought: string;
  score: number;
  children: ThoughtNode[];
  parent?: ThoughtNode;
}

class TreeOfThoughts {
  private numThoughts = 3;  // Branch factor
  private maxDepth = 4;
  
  async solve(problem: string): Promise<string> {
    const root: ThoughtNode = {
      state: problem,
      thought: "Initial problem",
      score: 0,
      children: []
    };
    
    // BFS exploration
    const solution = await this.bfsSearch(root);
    return this.extractSolution(solution);
  }
  
  private async bfsSearch(root: ThoughtNode): Promise<ThoughtNode> {
    let currentLevel = [root];
    
    for (let depth = 0; depth < this.maxDepth; depth++) {
      const nextLevel: ThoughtNode[] = [];
      
      for (const node of currentLevel) {
        // Generate multiple thoughts (branches)
        const thoughts = await this.generateThoughts(node);
        
        for (const thought of thoughts) {
          // Evaluate each thought
          const score = await this.evaluateThought(node.state, thought);
          
          const child: ThoughtNode = {
            state: this.applyThought(node.state, thought),
            thought,
            score,
            children: [],
            parent: node
          };
          
          node.children.push(child);
          
          // Only keep promising branches
          if (score > 0.5) {
            nextLevel.push(child);
          }
        }
      }
      
      // Sort by score, keep top-k
      nextLevel.sort((a, b) => b.score - a.score);
      currentLevel = nextLevel.slice(0, 5);  // Beam width
      
      // Check if solved
      const solved = currentLevel.find(n => this.isSolved(n));
      if (solved) return solved;
    }
    
    return currentLevel[0];  // Best effort
  }
  
  private async generateThoughts(node: ThoughtNode): Promise<string[]> {
    const response = await this.llm.complete({
      system: `Generate ${this.numThoughts} different approaches to continue solving this problem.
Return JSON array of strings, each a distinct next step.`,
      user: `Current state: ${node.state}\nProgress: ${node.thought}`
    });
    
    return JSON.parse(response);
  }
  
  private async evaluateThought(state: string, thought: string): Promise<number> {
    const response = await this.llm.complete({
      system: `Evaluate how promising this approach is for solving the problem.
Return a score from 0 to 1, where 1 = definitely leads to solution.
Return JSON: { "score": 0.X, "reason": "..." }`,
      user: `State: ${state}\nProposed next step: ${thought}`
    });
    
    return JSON.parse(response).score;
  }
}</code></pre>

  <h2>4ï¸âƒ£ å±‚çº§è§„åˆ’ (Hierarchical Planning)</h2>
  <div class="highlight">
    <strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong>å¤šå±‚æ¬¡åˆ†è§£â€”â€”æˆ˜ç•¥å±‚ â†’ æˆ˜æœ¯å±‚ â†’ æ‰§è¡Œå±‚
  </div>

  <div class="bilingual">
    <div class="zh">
      <p>Claude Code å’Œ Devin è¿™ç±» coding agent çš„æ ¸å¿ƒæ¶æ„ï¼š</p>
      <ul>
        <li><strong>Strategic Layer</strong>: "éœ€è¦é‡æ„æ•´ä¸ªè®¤è¯æ¨¡å—"</li>
        <li><strong>Tactical Layer</strong>: "å…ˆæ”¹ User modelï¼Œå†æ”¹ routesï¼Œå†æ”¹ middleware"</li>
        <li><strong>Execution Layer</strong>: "åœ¨ models/user.py ç¬¬ 23 è¡Œæ·»åŠ ..."</li>
      </ul>
      <p>æ¯ä¸€å±‚å¯ä»¥æœ‰<strong>ä¸åŒçš„æ¨¡å‹</strong>ï¼ˆä¸Šå±‚ç”¨å¼ºæ¨¡å‹è§„åˆ’ï¼Œä¸‹å±‚ç”¨å¿«æ¨¡å‹æ‰§è¡Œï¼‰</p>
    </div>
    <div class="en">
      <p>Core architecture of coding agents like Claude Code and Devin:</p>
      <ul>
        <li><strong>Strategic Layer</strong>: "Need to refactor entire auth module"</li>
        <li><strong>Tactical Layer</strong>: "First change User model, then routes, then middleware"</li>
        <li><strong>Execution Layer</strong>: "Add at line 23 of models/user.py..."</li>
      </ul>
      <p>Each layer can use <strong>different models</strong> (stronger for planning, faster for execution)</p>
    </div>
  </div>

  <div class="diagram">
Hierarchical Planning (Claude Code style):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STRATEGIC LAYER (Opus 4.5 / GPT-4)                                      â”‚
â”‚ "Add OAuth support to the application"                                  â”‚
â”‚                                                                          â”‚
â”‚ Decomposition:                                                           â”‚
â”‚  â€¢ Phase 1: Set up OAuth provider configs                               â”‚
â”‚  â€¢ Phase 2: Implement OAuth flow                                        â”‚
â”‚  â€¢ Phase 3: Handle token storage & refresh                              â”‚
â”‚  â€¢ Phase 4: Add UI components                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TACTICAL LAYER (Sonnet / GPT-4-mini)                                    â”‚
â”‚ Phase 2: Implement OAuth flow                                           â”‚
â”‚                                                                          â”‚
â”‚ Sub-tasks:                                                               â”‚
â”‚  â€¢ 2.1 Create /auth/google/login endpoint                               â”‚
â”‚  â€¢ 2.2 Create /auth/google/callback endpoint                            â”‚
â”‚  â€¢ 2.3 Add CSRF protection                                              â”‚
â”‚  â€¢ 2.4 Store OAuth state in session                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EXECUTION LAYER (Haiku / Direct tool calls)                             â”‚
â”‚ Task 2.1: Create /auth/google/login endpoint                            â”‚
â”‚                                                                          â”‚
â”‚ Actions:                                                                 â”‚
â”‚  â€¢ Read routes/auth.py                                                  â”‚
â”‚  â€¢ Edit: Add import for google_auth_oauthlib                            â”‚
â”‚  â€¢ Edit: Add /auth/google/login route                                   â”‚
â”‚  â€¢ Run: pytest tests/test_auth.py                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <h3>ğŸ’» å±‚çº§è§„åˆ’å®ç°</h3>
  <pre><code>interface HierarchicalPlan {
  strategic: StrategicGoal[];
  tactical: Map<string, TacticalTask[]>;
  execution: Map<string, ExecutionAction[]>;
}

interface StrategicGoal {
  id: string;
  description: string;
  successCriteria: string[];
}

interface TacticalTask {
  id: string;
  parentGoalId: string;
  description: string;
  estimatedComplexity: 'low' | 'medium' | 'high';
}

class HierarchicalAgent {
  private strategicModel: LLM;  // Opus 4.5 - expensive but smart
  private tacticalModel: LLM;   // Sonnet - balanced
  private executionModel: LLM;  // Haiku - fast and cheap
  
  async run(task: string): Promise<string> {
    // Layer 1: Strategic planning
    const strategy = await this.strategicPlan(task);
    console.log("ğŸ¯ Strategic goals:", strategy.map(g => g.description));
    
    for (const goal of strategy) {
      // Layer 2: Tactical decomposition
      const tactics = await this.tacticalPlan(goal);
      console.log(`ğŸ“‹ Tactics for "${goal.description}":`, tactics.length);
      
      for (const tactic of tactics) {
        // Layer 3: Execution
        await this.execute(tactic);
      }
      
      // Verify strategic goal completion
      if (!await this.verifyGoal(goal)) {
        // Re-plan at tactical level
        console.log("ğŸ”„ Goal not met, re-planning...");
        return this.run(task);  // Simplified: full restart
      }
    }
    
    return "Task completed successfully";
  }
  
  private async strategicPlan(task: string): Promise<StrategicGoal[]> {
    const response = await this.strategicModel.complete({
      system: `You are a senior architect. Break down the task into 
               high-level strategic goals. Each goal should be independently 
               verifiable. Return JSON array of goals.`,
      user: task
    });
    
    return JSON.parse(response);
  }
  
  private async tacticalPlan(goal: StrategicGoal): Promise<TacticalTask[]> {
    const response = await this.tacticalModel.complete({
      system: `Break down this strategic goal into tactical tasks.
               Each task should be completable in 5-15 minutes of work.`,
      user: `Goal: ${goal.description}\nSuccess criteria: ${goal.successCriteria.join(", ")}`
    });
    
    return JSON.parse(response);
  }
  
  private async execute(task: TacticalTask): Promise<void> {
    // Use ReAct agent with fast model for execution
    const executor = new ReActAgent(this.executionModel);
    await executor.run(task.description);
  }
}</code></pre>

  <h2>5ï¸âƒ£ åæ€ä¸é‡è§„åˆ’ (Reflection + Re-planning)</h2>
  <div class="highlight-blue">
    <strong>æ ¸å¿ƒæ€æƒ³ï¼š</strong>å®šæœŸæ£€æŸ¥è¿›åº¦ï¼Œå‘ç°é—®é¢˜æ—¶ä¸»åŠ¨è°ƒæ•´è®¡åˆ’
  </div>

  <div class="bilingual">
    <div class="zh">
      <p>å’Œ Plan-and-Execute çš„åŒºåˆ«ï¼šä¸åªæ˜¯"æ­¥éª¤å¤±è´¥æ—¶é‡è§„åˆ’"ï¼Œè€Œæ˜¯<strong>ä¸»åŠ¨åæ€</strong>ï¼š</p>
      <ul>
        <li>æ‰§è¡Œäº† N æ­¥åæš‚åœï¼Œè¯„ä¼°æ•´ä½“è¿›åº¦</li>
        <li>æ£€æŸ¥æ˜¯å¦åç¦»ç›®æ ‡</li>
        <li>è€ƒè™‘æ˜¯å¦æœ‰æ›´å¥½çš„æ–¹æ³•</li>
        <li>å†³å®šç»§ç»­ã€è°ƒæ•´è¿˜æ˜¯å½»åº•é‡æ¥</li>
      </ul>
      <p>Reflexion (NeurIPS 2023) æ˜¯è¿™ä¸ªæ–¹å‘çš„ä»£è¡¨è®ºæ–‡ã€‚</p>
    </div>
    <div class="en">
      <p>Different from Plan-and-Execute: not just "re-plan when step fails", but <strong>proactive reflection</strong>:</p>
      <ul>
        <li>Pause after N steps, evaluate overall progress</li>
        <li>Check if drifting from goal</li>
        <li>Consider if there's a better approach</li>
        <li>Decide to continue, adjust, or restart</li>
      </ul>
      <p>Reflexion (NeurIPS 2023) is a seminal paper in this direction.</p>
    </div>
  </div>

  <pre><code>class ReflectiveAgent {
  private reflectionInterval = 3;  // Reflect every 3 steps
  
  async run(task: string): Promise<string> {
    let plan = await this.createPlan(task);
    const history: StepResult[] = [];
    let stepCount = 0;
    
    while (!this.isComplete(plan, history)) {
      // Execute next step
      const result = await this.executeStep(plan.steps[plan.currentStep]);
      history.push(result);
      stepCount++;
      
      // Periodic reflection
      if (stepCount % this.reflectionInterval === 0) {
        const reflection = await this.reflect(task, plan, history);
        
        if (reflection.shouldReplan) {
          console.log(`ğŸ¤” Reflection: ${reflection.insight}`);
          console.log(`ğŸ”„ Action: ${reflection.action}`);
          
          if (reflection.action === 'restart') {
            // Completely new approach
            plan = await this.createPlan(task, reflection.insight);
            history.length = 0;
          } else if (reflection.action === 'adjust') {
            // Modify remaining steps
            plan = await this.adjustPlan(plan, reflection.insight);
          }
        }
      }
      
      plan.currentStep++;
    }
    
    return this.synthesize(history);
  }
  
  private async reflect(
    task: string, 
    plan: Plan, 
    history: StepResult[]
  ): Promise<Reflection> {
    const response = await this.llm.complete({
      system: `You are a reflective agent. Analyze the progress so far.

Consider:
1. Are we making progress toward the goal?
2. Have we discovered anything that changes our approach?
3. Are we going in circles or repeating mistakes?
4. Is there a more efficient path?

Return JSON:
{
  "progressAssessment": "on-track | slow | stuck | wrong-direction",
  "insight": "key observation",
  "shouldReplan": true/false,
  "action": "continue | adjust | restart"
}`,
      user: `Task: ${task}
Plan: ${JSON.stringify(plan.steps)}
History: ${JSON.stringify(history.map(h => h.summary))}`
    });
    
    return JSON.parse(response);
  }
}</code></pre>

  <h2>ğŸ“Š ç­–ç•¥å¯¹æ¯”ï¼šä½•æ—¶ç”¨ä»€ä¹ˆ</h2>

  <table>
    <thead>
      <tr>
        <th>ç­–ç•¥</th>
        <th>LLM è°ƒç”¨æ¬¡æ•°</th>
        <th>çµæ´»æ€§</th>
        <th>æœ€ä½³åœºæ™¯</th>
        <th>å…¸å‹åº”ç”¨</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Plan-and-Execute</strong></td>
        <td>ä¸­ç­‰ (æ¯æ­¥ 1 æ¬¡)</td>
        <td>é«˜</td>
        <td>é€šç”¨ä»»åŠ¡</td>
        <td>LangGraph, å¤§å¤šæ•° Agent</td>
      </tr>
      <tr>
        <td><strong>ReWOO</strong></td>
        <td>æœ€å°‘ (2-3 æ¬¡)</td>
        <td>ä½</td>
        <td>ç‹¬ç«‹æ­¥éª¤ã€æˆæœ¬æ•æ„Ÿ</td>
        <td>ç ”ç©¶é—®ç­”ã€æ•°æ®æ”¶é›†</td>
      </tr>
      <tr>
        <td><strong>Tree of Thoughts</strong></td>
        <td>æœ€å¤š (æ¯èŠ‚ç‚¹å¤šæ¬¡)</td>
        <td>æœ€é«˜</td>
        <td>å¤æ‚æ¨ç†ã€ä¼˜åŒ–é—®é¢˜</td>
        <td>æ•°å­¦ã€ç­–ç•¥ã€åˆ›æ„</td>
      </tr>
      <tr>
        <td><strong>Hierarchical</strong></td>
        <td>åˆ†å±‚ (è¶Šä½å±‚è¶Šå¤š)</td>
        <td>ä¸­</td>
        <td>é•¿å‘¨æœŸä»»åŠ¡</td>
        <td>Coding agents, é¡¹ç›®ç®¡ç†</td>
      </tr>
      <tr>
        <td><strong>Reflexion</strong></td>
        <td>ä¸­ç­‰ + åæ€</td>
        <td>é«˜</td>
        <td>å®¹æ˜“é™·å…¥å›°å¢ƒçš„ä»»åŠ¡</td>
        <td>Debugã€ç ”ç©¶ã€åˆ›ä½œ</td>
      </tr>
    </tbody>
  </table>

  <h2>ğŸ¯ Claude Code çš„è§„åˆ’ç­–ç•¥åˆ†æ</h2>
  <div class="highlight">
    <strong>Claude Code å®é™…ä½¿ç”¨çš„æ˜¯æ··åˆç­–ç•¥ï¼šHierarchical + Reflection</strong>
  </div>

  <div class="bilingual">
    <div class="zh">
      <p>è§‚å¯Ÿ Claude Code çš„è¡Œä¸ºå¯ä»¥æ¨æ–­å…¶æ¶æ„ï¼š</p>
      <ol>
        <li><strong>ä»»åŠ¡ç†è§£é˜¶æ®µ</strong>: è¯»å–ç›¸å…³æ–‡ä»¶ï¼Œç†è§£ä¸Šä¸‹æ–‡</li>
        <li><strong>è§„åˆ’é˜¶æ®µ</strong>: è¾“å‡º "I'll need to..." çš„é«˜å±‚è®¡åˆ’</li>
        <li><strong>æ‰§è¡Œé˜¶æ®µ</strong>: ä¸€æ­¥æ­¥æ‰§è¡Œï¼Œæœ‰è¯¦ç»†çš„æ€è€ƒè¿‡ç¨‹</li>
        <li><strong>éªŒè¯é˜¶æ®µ</strong>: è¿è¡Œæµ‹è¯•ã€æ£€æŸ¥ç»“æœ</li>
        <li><strong>åæ€é˜¶æ®µ</strong>: å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œåˆ†æåŸå› å¹¶è°ƒæ•´</li>
      </ol>
      <p>å…³é”®ç‰¹ç‚¹ï¼šå¤§é‡ä½¿ç”¨ <code>&lt;thinking&gt;</code> å—åšå†…éƒ¨æ¨ç†ï¼Œä¸æš´éœ²ç»™ç”¨æˆ·ã€‚</p>
    </div>
    <div class="en">
      <p>We can infer Claude Code's architecture from its behavior:</p>
      <ol>
        <li><strong>Understanding phase</strong>: Read relevant files, understand context</li>
        <li><strong>Planning phase</strong>: Output high-level plan ("I'll need to...")</li>
        <li><strong>Execution phase</strong>: Step-by-step with detailed reasoning</li>
        <li><strong>Verification phase</strong>: Run tests, check results</li>
        <li><strong>Reflection phase</strong>: If tests fail, analyze and adjust</li>
      </ol>
      <p>Key feature: Heavy use of <code>&lt;thinking&gt;</code> blocks for internal reasoning, hidden from user.</p>
    </div>
  </div>

  <div class="interview">
    <h3>ğŸ’¼ é¢è¯•é¢˜ï¼šè®¾è®¡ä¸€ä¸ª Coding Agent çš„è§„åˆ’ç³»ç»Ÿ</h3>
    <p><strong>é¢˜ç›®ï¼š</strong>è®¾è®¡ä¸€ä¸ªèƒ½è‡ªåŠ¨å®Œæˆä»£ç ä»»åŠ¡çš„ Agent çš„è§„åˆ’æ¨¡å—ã€‚è¦æ±‚ï¼š</p>
    <ul>
      <li>å¤„ç†å¤æ‚ã€å¤šæ­¥éª¤çš„ç¼–ç ä»»åŠ¡</li>
      <li>èƒ½ä»é”™è¯¯ä¸­æ¢å¤</li>
      <li>æˆæœ¬å¯æ§ï¼ˆé¿å…æ— é™å¾ªç¯ï¼‰</li>
    </ul>
    <hr style="border-color: rgba(255,255,255,0.3);">
    <p><strong>å‚è€ƒç­”æ¡ˆè¦ç‚¹ï¼š</strong></p>
    <ol>
      <li><strong>å±‚çº§è§„åˆ’</strong>ï¼šå…ˆæŠŠä»»åŠ¡æ‹†æˆ phasesï¼Œæ¯ä¸ª phase æ‹†æˆ tasksï¼Œæ¯ä¸ª task æ‹†æˆ actions</li>
      <li><strong>æ¨¡å‹åˆ†é…</strong>ï¼šé«˜å±‚ç”¨å¼ºæ¨¡å‹ï¼ˆGPT-4/Opusï¼‰ï¼Œæ‰§è¡Œå±‚ç”¨å¿«æ¨¡å‹ï¼ˆHaiku/GPT-3.5ï¼‰</li>
      <li><strong>éªŒè¯èŠ‚ç‚¹</strong>ï¼šæ¯ä¸ª task å®Œæˆåè¿è¡Œæµ‹è¯•ï¼Œå¤±è´¥åˆ™è§¦å‘é‡è§„åˆ’</li>
      <li><strong>åæ€æœºåˆ¶</strong>ï¼šæ¯ N æ­¥åšä¸€æ¬¡åæ€ï¼Œæ£€æŸ¥æ˜¯å¦åç¦»ç›®æ ‡</li>
      <li><strong>æˆæœ¬æ§åˆ¶</strong>ï¼š
        <ul>
          <li>è®¾ç½® max_steps ä¸Šé™</li>
          <li>è®°å½•å·²å°è¯•çš„æ–¹æ³•ï¼Œé¿å…å¾ªç¯</li>
          <li>å¤±è´¥ 3 æ¬¡åŒä¸€æ­¥éª¤æ—¶ï¼Œå‡çº§åˆ°æ›´å¼ºæ¨¡å‹æˆ–è¯·æ±‚äººå·¥ä»‹å…¥</li>
        </ul>
      </li>
      <li><strong>çŠ¶æ€ç®¡ç†</strong>ï¼šæŒä¹…åŒ– plan å’Œ historyï¼Œæ”¯æŒæ–­ç‚¹ç»­ä¼ </li>
    </ol>
  </div>

  <div class="interview">
    <h3>ğŸ’¼ é¢è¯•è¿½é—®ï¼šå¦‚ä½•å¤„ç†è§„åˆ’å¤±è´¥ï¼Ÿ</h3>
    <p><strong>ç­”æ¡ˆæ€è·¯ï¼š</strong></p>
    <ol>
      <li><strong>åˆ†çº§å¤„ç†</strong>ï¼š
        <ul>
          <li>Action å¤±è´¥ â†’ é‡è¯•ï¼ˆæœ€å¤š 3 æ¬¡ï¼‰</li>
          <li>Task å¤±è´¥ â†’ é‡æ–°è§„åˆ’ task çš„ actions</li>
          <li>Phase å¤±è´¥ â†’ é‡æ–°è¯„ä¼°æ•´ä½“æ–¹æ¡ˆ</li>
        </ul>
      </li>
      <li><strong>é”™è¯¯åˆ†ç±»</strong>ï¼š
        <ul>
          <li>ä¸´æ—¶é”™è¯¯ï¼ˆç½‘ç»œã€è¶…æ—¶ï¼‰â†’ ç®€å•é‡è¯•</li>
          <li>é€»è¾‘é”™è¯¯ï¼ˆä»£ç  bugï¼‰â†’ éœ€è¦åˆ†æåŸå› </li>
          <li>æ–¹å‘é”™è¯¯ï¼ˆæ€è·¯ä¸å¯¹ï¼‰â†’ éœ€è¦å¤§å¹…è°ƒæ•´</li>
        </ul>
      </li>
      <li><strong>å­¦ä¹ æœºåˆ¶</strong>ï¼šæŠŠå¤±è´¥çš„æ–¹æ³•è®°å½•ä¸‹æ¥ï¼Œå‘Šè¯‰åç»­æ­¥éª¤"ä¸è¦ç”¨è¿™ä¸ªæ–¹æ³•"</li>
    </ol>
  </div>

  <h2>ğŸ“š å¯å­¦ä¹ çš„æ¨¡å¼ / Patterns to Learn</h2>
  
  <div class="highlight-green">
    <h4>âœ… Pattern 1: åˆ†å±‚æ¨¡å‹åˆ†é…</h4>
    <p>ä¸åŒå±‚çº§ç”¨ä¸åŒæ¨¡å‹ï¼Œå¹³è¡¡è´¨é‡å’Œæˆæœ¬ã€‚è§„åˆ’ç”¨å¼ºæ¨¡å‹ï¼Œæ‰§è¡Œç”¨å¿«æ¨¡å‹ã€‚</p>
    <pre><code>// æ¨¡å‹åˆ†é…ç­–ç•¥
const modelForLayer = {
  strategic: 'opus-4.5',      // è´µä½†èªæ˜
  tactical: 'sonnet-4',       // å¹³è¡¡
  execution: 'haiku-4',       // å¿«ä¸”ä¾¿å®œ
  reflection: 'sonnet-4'      // éœ€è¦ä¸€å®šæ¨ç†èƒ½åŠ›
};</code></pre>
  </div>

  <div class="highlight-green">
    <h4>âœ… Pattern 2: å¸¦ä¸Šé™çš„é‡è¯•æœºåˆ¶</h4>
    <p>ä»»ä½•å¾ªç¯éƒ½è¦æœ‰ max_attemptsï¼Œé¿å…æ— é™çƒ§é’±ã€‚</p>
    <pre><code>const MAX_RETRIES = 3;
const MAX_TOTAL_STEPS = 50;

async function executeWithRetry(step, attempts = 0) {
  if (attempts >= MAX_RETRIES) {
    throw new Error(`Step failed after ${MAX_RETRIES} attempts`);
  }
  try {
    return await execute(step);
  } catch (e) {
    return executeWithRetry(step, attempts + 1);
  }
}</code></pre>
  </div>

  <div class="highlight-green">
    <h4>âœ… Pattern 3: éªŒè¯èŠ‚ç‚¹</h4>
    <p>æ¯ä¸ªå…³é”®æ­¥éª¤åéƒ½è¦éªŒè¯ï¼Œä¸è¦ç­‰åˆ°æœ€åæ‰å‘ç°é—®é¢˜ã€‚</p>
    <pre><code>async function executePhase(phase) {
  for (const task of phase.tasks) {
    await execute(task);
    
    // éªŒè¯èŠ‚ç‚¹
    const verification = await verify(task);
    if (!verification.passed) {
      // ç«‹å³å¤„ç†ï¼Œä¸è¦ç»§ç»­
      await handleFailure(task, verification);
    }
  }
}</code></pre>
  </div>

  <h2>ğŸ”— ç³»åˆ—å›é¡¾ / Series Recap</h2>
  
  <div class="architecture">
    <h4>Agent ç³»åˆ—å®Œæ•´çŸ¥è¯†å›¾è°±</h4>
    <pre>
Day 1: ReAct Pattern & Tool Use
  â””â”€â”€ Agent å¦‚ä½•æ€è€ƒå’Œè¡ŒåŠ¨çš„åŸºç¡€å¾ªç¯
  
Day 2: Multi-Agent Collaboration  
  â””â”€â”€ å¤šä¸ª Agent å¦‚ä½•åä½œï¼ˆCrewAI vs AutoGenï¼‰
  
Day 3: Agent Memory
  â””â”€â”€ Agent å¦‚ä½•è®°ä½å’Œåˆ©ç”¨ä¸Šä¸‹æ–‡
  
Day 4: Agent Planning (ä»Šå¤©)
  â””â”€â”€ Agent å¦‚ä½•åˆ†è§£å’Œè§„åˆ’å¤æ‚ä»»åŠ¡

Integration:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚              Complete Agent System               â”‚
  â”‚                                                  â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ Planning Layer                            â”‚  â”‚
  â”‚  â”‚ (Plan-and-Execute / Hierarchical / ToT)  â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚                        â”‚                        â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ Execution Layer (ReAct Loop)             â”‚  â”‚
  â”‚  â”‚                                          â”‚  â”‚
  â”‚  â”‚  Thought â†’ Action â†’ Observation â†’ ...   â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚             â”‚                â”‚                  â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ Memory System     â”‚ â”‚ Tool System       â”‚  â”‚
  â”‚  â”‚ (Buffer/Vector/   â”‚ â”‚ (Function Call)   â”‚  â”‚
  â”‚  â”‚  Entity Memory)   â”‚ â”‚                   â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚                                                â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
  â”‚  â”‚ Multi-Agent Coordination (if needed)      â”‚â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    </pre>
  </div>

  <div class="follow-up">
    <h3>ğŸ’¬ åç»­è®¨è®º / Follow-up Discussion</h3>
    <p>Agent ç³»åˆ—åˆ°æ­¤å®Œç»“ï¼æ¥ä¸‹æ¥å¯ä»¥æ·±å…¥ï¼š</p>
    <ul>
      <li><strong>RAG ç³»ç»Ÿè®¾è®¡</strong> - Pipelineã€Chunkingã€Retrieval ç­–ç•¥</li>
      <li><strong>è®¾è®¡ ChatGPT é¢è¯•é¢˜</strong> - ç«¯åˆ°ç«¯å¯¹è¯ç³»ç»Ÿ system design</li>
      <li><strong>Claude Code æºç åˆ†æ</strong> - å¦‚æœ Anthropic å¼€æºçš„è¯ ğŸ˜„</li>
    </ul>
    <p>æœ‰é—®é¢˜éšæ—¶é—®ï¼</p>
  </div>

  <hr>
  <p style="color: #666; font-size: 14px;">
    ğŸ“… 2026-02-04 | ğŸ¤– Agent ç³»åˆ— Day 4 (å®Œç»“ç¯‡) | Phase 1.2 Agent æ¶æ„ä¸å¼€å‘
  </p>
</body>
</html>
