<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2026-02-03 - Agent Memory Design</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; line-height: 1.7; color: #333; }
    .bilingual { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 15px 0; }
    @media (max-width: 768px) { .bilingual { grid-template-columns: 1fr; } }
    .zh { border-left: 3px solid #f9ab00; padding-left: 15px; }
    .en { border-left: 3px solid #1a73e8; padding-left: 15px; }
    h1 { color: #1a73e8; border-bottom: 2px solid #f9ab00; padding-bottom: 10px; }
    h2 { color: #3c4043; margin-top: 30px; }
    .architecture { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; }
    pre { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 13px; }
    code { font-family: 'SF Mono', Monaco, Consolas, monospace; }
    .inline-code { background: #f1f3f4; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
    .highlight { background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f9ab00; }
    .highlight-blue { background: #e8f4fd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #1a73e8; }
    .diagram { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; font-family: monospace; white-space: pre; font-size: 12px; overflow-x: auto; }
    .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; }
    .comparison > div { background: #f8f9fa; padding: 15px; border-radius: 8px; }
    .interview { background: #fce8e6; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ea4335; }
    .pattern { background: #e6f4ea; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #34a853; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { border: 1px solid #dadce0; padding: 10px; text-align: left; }
    th { background: #f8f9fa; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin: 2px; }
    .tag-interview { background: #fce8e6; color: #c5221f; }
    .tag-practical { background: #e6f4ea; color: #137333; }
    .follow-up { margin-top: 30px; padding: 15px; border: 1px dashed #dadce0; border-radius: 8px; }
    a { color: #1a73e8; }
  </style>
</head>
<body>
  <h1>ğŸ§  Agent Memory: çŸ­æœŸ vs é•¿æœŸè®°å¿†è®¾è®¡</h1>
  <p>
    <span class="tag tag-interview">é¢è¯•çƒ­ç‚¹</span>
    <span class="tag tag-practical">å®ç”¨æŠ€èƒ½</span>
    | ğŸ“… 2026-02-03 | ç³»åˆ—ï¼šAgent æ¶æ„ (4/N)
  </p>
  
  <h2>ğŸ“– ä¸ºä»€ä¹ˆ Agent éœ€è¦ Memoryï¼Ÿ</h2>
  <div class="bilingual">
    <div class="zh">
      <p><strong>æ ¸å¿ƒé—®é¢˜</strong>ï¼šLLM æ˜¯æ— çŠ¶æ€çš„ã€‚æ¯æ¬¡è°ƒç”¨éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œæ¨¡å‹ä¸è®°å¾—ä¹‹å‰è¯´è¿‡ä»€ä¹ˆã€‚</p>
      <p><strong>è§£å†³æ–¹æ¡ˆ</strong>ï¼šåœ¨ prompt ä¸­æ³¨å…¥å†å²ä¿¡æ¯ï¼Œè®©æ¨¡å‹"å‡è£…"è®°å¾—ã€‚</p>
      <p><strong>æŒ‘æˆ˜</strong>ï¼šContext window æœ‰é™ï¼ˆ4K-200K tokensï¼‰ï¼Œä¸èƒ½æ— é™å¡å†å²ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Core Problem</strong>: LLMs are stateless. Each API call is independent - the model has no memory of previous interactions.</p>
      <p><strong>Solution</strong>: Inject history into the prompt so the model can "pretend" to remember.</p>
      <p><strong>Challenge</strong>: Context window is limited (4K-200K tokens), can't stuff unlimited history.</p>
    </div>
  </div>

  <div class="highlight">
    <strong>ğŸ’¡ å…³é”®æ´å¯Ÿ / Key Insight</strong><br>
    Memory è®¾è®¡æœ¬è´¨æ˜¯ä¸€ä¸ª<strong>ä¿¡æ¯æ£€ç´¢+å‹ç¼©</strong>é—®é¢˜ï¼šå¦‚ä½•ç”¨æœ‰é™çš„ tokens ä¼ é€’æœ€ç›¸å…³çš„å†å²ä¿¡æ¯ï¼Ÿ
  </div>

  <h2>ğŸ—ï¸ Memory ç±»å‹æ€»è§ˆ</h2>
  
  <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agent Memory Architecture                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    SHORT-TERM MEMORY                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚   Buffer     â”‚  â”‚   Window     â”‚  â”‚    Summary       â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  (All msgs)  â”‚  â”‚  (Last K)    â”‚  â”‚   (Compressed)   â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â”‚           Within current conversation session                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â†“                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    LONG-TERM MEMORY                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚ Vector Store â”‚  â”‚   Entity     â”‚  â”‚   Episodic       â”‚   â”‚ â”‚
â”‚  â”‚  â”‚ (Semantic)   â”‚  â”‚   Memory     â”‚  â”‚   Memory         â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â”‚           Persistent across sessions                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <h2>ğŸ“ Short-Term Memory è®¾è®¡</h2>
  
  <h3>Pattern 1: Buffer Memory (å…¨é‡)</h3>
  <div class="bilingual">
    <div class="zh">
      <p><strong>åšæ³•</strong>ï¼šä¿å­˜æ‰€æœ‰å¯¹è¯å†å²ï¼Œæ¯æ¬¡éƒ½å‘é€å®Œæ•´å†å²ç»™ LLMã€‚</p>
      <p><strong>ä¼˜ç‚¹</strong>ï¼šç®€å•ï¼Œä¸Šä¸‹æ–‡å®Œæ•´</p>
      <p><strong>ç¼ºç‚¹</strong>ï¼šå®¹æ˜“è¶…å‡º context limitï¼Œæˆæœ¬é«˜</p>
      <p><strong>é€‚ç”¨</strong>ï¼šçŸ­å¯¹è¯ï¼ˆ<20è½®ï¼‰ï¼ŒContext å……è¶³çš„åœºæ™¯</p>
    </div>
    <div class="en">
      <p><strong>Approach</strong>: Save all messages, send complete history to LLM every time.</p>
      <p><strong>Pros</strong>: Simple, full context preserved</p>
      <p><strong>Cons</strong>: Easily exceeds context limit, expensive</p>
      <p><strong>Use when</strong>: Short conversations (<20 turns), ample context window</p>
    </div>
  </div>
  
  <pre><code class="language-typescript">// Buffer Memory - æœ€ç®€å•çš„å®ç°
interface Message {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

class BufferMemory {
  private messages: Message[] = [];
  
  add(message: Message) {
    this.messages.push(message);
  }
  
  getMessages(): Message[] {
    return [...this.messages];
  }
  
  // ä¼°ç®— token æ•°ï¼ˆç²—ç•¥ï¼š4 chars â‰ˆ 1 tokenï¼‰
  estimateTokens(): number {
    const text = this.messages.map(m => m.content).join('');
    return Math.ceil(text.length / 4);
  }
}

// ä½¿ç”¨
const memory = new BufferMemory();
memory.add({ role: 'user', content: 'What is RAG?' });
memory.add({ role: 'assistant', content: 'RAG stands for...' });

// è°ƒç”¨ LLM æ—¶
const response = await llm.chat({
  messages: [
    { role: 'system', content: systemPrompt },
    ...memory.getMessages(),  // å…¨éƒ¨å†å²
    { role: 'user', content: newQuestion }
  ]
});</code></pre>

  <h3>Pattern 2: Window Memory (æ»‘åŠ¨çª—å£)</h3>
  <div class="bilingual">
    <div class="zh">
      <p><strong>åšæ³•</strong>ï¼šåªä¿ç•™æœ€è¿‘ K æ¡æ¶ˆæ¯</p>
      <p><strong>æƒè¡¡</strong>ï¼šK è¶Šå¤§ï¼Œä¸Šä¸‹æ–‡è¶Šå®Œæ•´ï¼Œä½†æˆæœ¬è¶Šé«˜</p>
      <p><strong>å¸¸è§è®¾ç½®</strong>ï¼šK = 10-20 æ¡æ¶ˆæ¯</p>
    </div>
    <div class="en">
      <p><strong>Approach</strong>: Keep only the last K messages</p>
      <p><strong>Trade-off</strong>: Larger K = more context but higher cost</p>
      <p><strong>Common setting</strong>: K = 10-20 messages</p>
    </div>
  </div>

  <pre><code class="language-typescript">class WindowMemory {
  private messages: Message[] = [];
  private readonly windowSize: number;
  
  constructor(windowSize: number = 10) {
    this.windowSize = windowSize;
  }
  
  add(message: Message) {
    this.messages.push(message);
    // è¶…å‡ºçª—å£æ—¶ï¼Œç§»é™¤æœ€è€çš„
    while (this.messages.length > this.windowSize) {
      this.messages.shift();
    }
  }
  
  getMessages(): Message[] {
    return [...this.messages];
  }
}</code></pre>

  <div class="highlight">
    <strong>âš ï¸ çª—å£è®°å¿†çš„é™·é˜±</strong><br>
    ç”¨æˆ·ç¬¬ä¸€è½®è¯´"æˆ‘å«å¼ ä¸‰"ï¼Œ20 è½®åé—®"æˆ‘å«ä»€ä¹ˆ"ï¼ŒAgent å°±ä¸è®°å¾—äº†ï¼<br>
    <strong>è§£æ³•</strong>ï¼šWindow + Summary ç»„åˆï¼Œæˆ–æå–å…³é”®ä¿¡æ¯åˆ° Entity Memoryã€‚
  </div>

  <h3>Pattern 3: Summary Memory (æ‘˜è¦)</h3>
  <div class="bilingual">
    <div class="zh">
      <p><strong>åšæ³•</strong>ï¼šç”¨ LLM æŠŠæ—§å¯¹è¯å‹ç¼©æˆæ‘˜è¦</p>
      <p><strong>ä¼˜ç‚¹</strong>ï¼šå›ºå®š token å¼€é”€ï¼Œå¯å¤„ç†è¶…é•¿å¯¹è¯</p>
      <p><strong>ç¼ºç‚¹</strong>ï¼šé¢å¤– LLM è°ƒç”¨æˆæœ¬ï¼Œå¯èƒ½ä¸¢å¤±ç»†èŠ‚</p>
    </div>
    <div class="en">
      <p><strong>Approach</strong>: Use LLM to compress old conversation into summary</p>
      <p><strong>Pros</strong>: Fixed token cost, handles very long conversations</p>
      <p><strong>Cons</strong>: Extra LLM call cost, may lose details</p>
    </div>
  </div>

  <pre><code class="language-typescript">class SummaryMemory {
  private summary: string = '';
  private recentMessages: Message[] = [];
  private readonly recentLimit = 4;  // ä¿ç•™æœ€è¿‘å‡ æ¡åŸæ–‡
  
  async add(message: Message, llm: LLM) {
    this.recentMessages.push(message);
    
    // å½“ç§¯ç´¯å¤ªå¤šæ—¶ï¼Œå‹ç¼©æˆæ‘˜è¦
    if (this.recentMessages.length > this.recentLimit * 2) {
      const toSummarize = this.recentMessages.slice(0, -this.recentLimit);
      this.recentMessages = this.recentMessages.slice(-this.recentLimit);
      
      // ç”¨ LLM å‹ç¼©
      const newSummary = await llm.chat({
        messages: [{
          role: 'user',
          content: `Summarize this conversation, preserving key facts:
          
Previous summary: ${this.summary || 'None'}

New messages:
${toSummarize.map(m => `${m.role}: ${m.content}`).join('\n')}

Provide a concise summary:`
        }]
      });
      
      this.summary = newSummary;
    }
  }
  
  getContext(): string {
    return `[Previous conversation summary]
${this.summary}

[Recent messages]
${this.recentMessages.map(m => `${m.role}: ${m.content}`).join('\n')}`;
  }
}</code></pre>

  <h3>ç»„åˆæ¨¡å¼ï¼šSummary + Window</h3>
  <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Summary + Window Memory                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  [System Prompt]                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  [Summary of older messages]  â† å‹ç¼©çš„å†å² (~500 tokens)    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  [Recent K messages]          â† åŸæ–‡ä¿ç•™ (~2000 tokens)     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  [Current user message]                                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <h2>ğŸ’¾ Long-Term Memory è®¾è®¡</h2>
  
  <h3>Pattern 4: Vector Store Memory (è¯­ä¹‰æ£€ç´¢)</h3>
  <div class="bilingual">
    <div class="zh">
      <p><strong>åšæ³•</strong>ï¼šæŠŠå†å²å¯¹è¯ embed åå­˜å…¥å‘é‡æ•°æ®åº“ï¼ŒæŒ‰ç›¸å…³æ€§æ£€ç´¢</p>
      <p><strong>å…³é”®å†³ç­–</strong>ï¼š</p>
      <ul>
        <li>ç²’åº¦ï¼šæŒ‰æ¶ˆæ¯å­˜ï¼ŸæŒ‰è½®æ¬¡å­˜ï¼ŸæŒ‰ session å­˜ï¼Ÿ</li>
        <li>æ£€ç´¢æ•°é‡ï¼šTop-K å–å¤šå°‘ï¼Ÿ</li>
        <li>é˜ˆå€¼ï¼šç›¸ä¼¼åº¦ä½äºå¤šå°‘å°±ä¸è¦ï¼Ÿ</li>
      </ul>
    </div>
    <div class="en">
      <p><strong>Approach</strong>: Embed conversation history, store in vector DB, retrieve by relevance</p>
      <p><strong>Key decisions</strong>:</p>
      <ul>
        <li>Granularity: Store per message? Per turn? Per session?</li>
        <li>Retrieval count: How many Top-K?</li>
        <li>Threshold: Minimum similarity score?</li>
      </ul>
    </div>
  </div>

  <pre><code class="language-typescript">import { OpenAIEmbeddings } from 'langchain/embeddings/openai';
import { PineconeStore } from 'langchain/vectorstores/pinecone';

class VectorMemory {
  private vectorStore: PineconeStore;
  private embeddings: OpenAIEmbeddings;
  
  constructor(vectorStore: PineconeStore) {
    this.vectorStore = vectorStore;
    this.embeddings = new OpenAIEmbeddings();
  }
  
  // å­˜å‚¨å¯¹è¯ï¼ˆå»ºè®®æŒ‰ turn è€Œéå•æ¡æ¶ˆæ¯ï¼‰
  async store(turn: { user: string; assistant: string }, metadata: any) {
    const text = `User: ${turn.user}\nAssistant: ${turn.assistant}`;
    await this.vectorStore.addDocuments([{
      pageContent: text,
      metadata: {
        ...metadata,
        timestamp: Date.now(),
        type: 'conversation'
      }
    }]);
  }
  
  // æ£€ç´¢ç›¸å…³è®°å¿†
  async retrieve(query: string, k: number = 3): Promise<string[]> {
    const results = await this.vectorStore.similaritySearchWithScore(query, k);
    
    // è¿‡æ»¤ä½ç›¸å…³æ€§ç»“æœ
    const relevant = results
      .filter(([_, score]) => score > 0.7)
      .map(([doc, _]) => doc.pageContent);
    
    return relevant;
  }
}

// ä½¿ç”¨æ—¶
const relevantMemories = await vectorMemory.retrieve(userQuestion);
const context = relevantMemories.length > 0
  ? `Relevant past conversations:\n${relevantMemories.join('\n---\n')}`
  : '';</code></pre>

  <div class="highlight-blue">
    <strong>ğŸ¯ å‘é‡å­˜å‚¨çš„ç²’åº¦å»ºè®®</strong><br>
    <table>
      <tr><th>ç²’åº¦</th><th>ä¼˜ç‚¹</th><th>ç¼ºç‚¹</th><th>é€‚ç”¨åœºæ™¯</th></tr>
      <tr><td>å•æ¶ˆæ¯</td><td>ç²¾å‡†æ£€ç´¢</td><td>ç¼ºå°‘ä¸Šä¸‹æ–‡</td><td>FAQ é—®ç­”</td></tr>
      <tr><td>å¯¹è¯è½®æ¬¡</td><td>ä¸Šä¸‹æ–‡å®Œæ•´</td><td>ä¸­ç­‰ç²’åº¦</td><td>é€šç”¨ Agent</td></tr>
      <tr><td>æ•´ä¸ª Session</td><td>å®Œæ•´è¯­å¢ƒ</td><td>æ£€ç´¢å¯èƒ½ä¸å‡†</td><td>é•¿æœŸè®°å¿†å½’æ¡£</td></tr>
    </table>
  </div>

  <h3>Pattern 5: Entity Memory (å®ä½“æå–)</h3>
  <div class="bilingual">
    <div class="zh">
      <p><strong>åšæ³•</strong>ï¼šç”¨ LLM æå–å¯¹è¯ä¸­çš„å…³é”®å®ä½“ï¼ˆäººåã€åå¥½ã€äº‹å®ï¼‰ï¼Œç»“æ„åŒ–å­˜å‚¨</p>
      <p><strong>ä¼˜ç‚¹</strong>ï¼šç²¾å‡†è®°ä½é‡è¦ä¿¡æ¯ï¼Œä¸ä¾èµ–ç›¸ä¼¼åº¦æ£€ç´¢</p>
      <p><strong>é€‚ç”¨</strong>ï¼šä¸ªäººåŠ©æ‰‹ï¼ˆè®°ä½ç”¨æˆ·ä¿¡æ¯ï¼‰ã€å®¢æœï¼ˆè®°ä½å®¢æˆ·èƒŒæ™¯ï¼‰</p>
    </div>
    <div class="en">
      <p><strong>Approach</strong>: Use LLM to extract key entities (names, preferences, facts), store structured</p>
      <p><strong>Pros</strong>: Precisely remember important info, doesn't rely on similarity search</p>
      <p><strong>Use case</strong>: Personal assistant, customer service</p>
    </div>
  </div>

  <pre><code class="language-typescript">interface EntityStore {
  [entityName: string]: {
    type: 'person' | 'preference' | 'fact';
    description: string;
    lastUpdated: Date;
  };
}

class EntityMemory {
  private entities: EntityStore = {};
  
  async extractAndStore(conversation: string, llm: LLM) {
    const extraction = await llm.chat({
      messages: [{
        role: 'user',
        content: `Extract key entities from this conversation:

${conversation}

Output JSON:
{
  "entities": [
    { "name": "...", "type": "person|preference|fact", "description": "..." }
  ]
}`
      }]
    });
    
    const { entities } = JSON.parse(extraction);
    for (const entity of entities) {
      this.entities[entity.name] = {
        type: entity.type,
        description: entity.description,
        lastUpdated: new Date()
      };
    }
  }
  
  getRelevantEntities(query: string): string {
    // ç®€å•å®ç°ï¼šå…³é”®è¯åŒ¹é…
    // é«˜çº§å®ç°ï¼šå¯ä»¥ç”¨ embedding åŒ¹é…
    const relevant = Object.entries(this.entities)
      .filter(([name]) => query.toLowerCase().includes(name.toLowerCase()))
      .map(([name, info]) => `${name}: ${info.description}`);
    
    return relevant.join('\n');
  }
}

// ç¤ºä¾‹å­˜å‚¨ç»“æœï¼š
// {
//   "å¼ ä¸‰": { type: "person", description: "ç”¨æˆ·çš„åå­—ï¼Œç¨‹åºå‘˜" },
//   "dark mode": { type: "preference", description: "ç”¨æˆ·åå¥½æ·±è‰²ä¸»é¢˜" }
// }</code></pre>

  <h2>ğŸ¨ å®æˆ˜æ¶æ„ï¼šç»„åˆæ‰€æœ‰ Memory</h2>

  <div class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Production Agent Memory System                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                      â”‚                      â”‚
            â–¼                      â–¼                      â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    Entity     â”‚     â”‚    Vector     â”‚     â”‚   Summary +   â”‚
    â”‚    Memory     â”‚     â”‚    Memory     â”‚     â”‚    Window     â”‚
    â”‚  (å…³é”®å®ä½“)   â”‚     â”‚  (è¯­ä¹‰æ£€ç´¢)   â”‚     â”‚  (å½“å‰ä¼šè¯)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                      â”‚                      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Memory Composer         â”‚
                    â”‚  (ç»„è£…æœ€ç»ˆ prompt context)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FINAL PROMPT:                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ [System Prompt]                                                 â”‚ â”‚
â”‚  â”‚ [Entity Context] - "ç”¨æˆ·å: å¼ ä¸‰, åå¥½: dark mode"              â”‚ â”‚
â”‚  â”‚ [Retrieved Memories] - "2å¤©å‰è®¨è®ºè¿‡ RAG æ¶æ„..."                â”‚ â”‚
â”‚  â”‚ [Conversation Summary] - "ä¹‹å‰è®¨è®ºäº† Agent è®¾è®¡æ¨¡å¼..."         â”‚ â”‚
â”‚  â”‚ [Recent Messages] - æœ€è¿‘ 5 æ¡åŸæ–‡                               â”‚ â”‚
â”‚  â”‚ [Current Question]                                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <pre><code class="language-typescript">class CompositeMemory {
  private entityMemory: EntityMemory;
  private vectorMemory: VectorMemory;
  private conversationMemory: SummaryWindowMemory;
  
  async buildContext(currentQuery: string): Promise<string> {
    // 1. è·å–å®ä½“ä¿¡æ¯
    const entityContext = this.entityMemory.getRelevantEntities(currentQuery);
    
    // 2. æ£€ç´¢ç›¸å…³å†å²å¯¹è¯
    const retrievedMemories = await this.vectorMemory.retrieve(currentQuery, 3);
    
    // 3. è·å–å½“å‰ä¼šè¯ä¸Šä¸‹æ–‡
    const conversationContext = this.conversationMemory.getContext();
    
    // 4. ç»„è£…ï¼ˆæ³¨æ„æ§åˆ¶æ€» token æ•°ï¼‰
    const sections: string[] = [];
    
    if (entityContext) {
      sections.push(`[Known Information]\n${entityContext}`);
    }
    
    if (retrievedMemories.length > 0) {
      sections.push(`[Relevant Past Conversations]\n${retrievedMemories.join('\n---\n')}`);
    }
    
    sections.push(`[Current Conversation]\n${conversationContext}`);
    
    return sections.join('\n\n');
  }
}

// Token é¢„ç®—åˆ†é…å»ºè®®ï¼š
// - Entity: ~200 tokens
// - Retrieved memories: ~1000 tokens
// - Summary: ~500 tokens
// - Recent messages: ~2000 tokens
// - Current query + response: ~4000 tokens
// Total: ~8000 tokens for memory (with GPT-4-128K, plenty of room)</code></pre>

  <h2>ğŸ¤ é¢è¯•é¢˜ä¸è§£ç­”</h2>

  <div class="interview">
    <h4>Q1: å¦‚ä½•è®¾è®¡ä¸€ä¸ªèƒ½è®°ä½ç”¨æˆ·ä¿¡æ¯çš„ AI åŠ©æ‰‹ï¼Ÿ</h4>
    <p><strong>ç­”é¢˜æ¡†æ¶ï¼š</strong></p>
    <ol>
      <li><strong>éœ€æ±‚æ¾„æ¸…</strong>ï¼šè®°ä½ä»€ä¹ˆï¼Ÿï¼ˆåå¥½ã€å§“åã€å†å²å¯¹è¯ï¼‰å¤šä¹…ï¼Ÿï¼ˆsessionã€æ°¸ä¹…ï¼‰</li>
      <li><strong>çŸ­æœŸè®°å¿†</strong>ï¼šWindow Memory ä¿æŒå½“å‰å¯¹è¯è¿è´¯</li>
      <li><strong>é•¿æœŸè®°å¿†</strong>ï¼š
        <ul>
          <li>Entity Memory - æå–å…³é”®ä¿¡æ¯ç»“æ„åŒ–å­˜å‚¨</li>
          <li>Vector Memory - å¯¹è¯å†å²è¯­ä¹‰æ£€ç´¢</li>
        </ul>
      </li>
      <li><strong>éšç§è€ƒè™‘</strong>ï¼šæ•æ„Ÿä¿¡æ¯åŠ å¯†ï¼Œæ”¯æŒç”¨æˆ·åˆ é™¤</li>
      <li><strong>Token é¢„ç®—</strong>ï¼šè®¾è®¡ memory budgetï¼Œä¼˜å…ˆçº§æ’åº</li>
    </ol>
  </div>

  <div class="interview">
    <h4>Q2: å¯¹è¯å¤ªé•¿è¶…å‡º context limit æ€ä¹ˆåŠï¼Ÿ</h4>
    <p><strong>ç­”é¢˜è¦ç‚¹ï¼š</strong></p>
    <ol>
      <li><strong>æ‘˜è¦å‹ç¼©</strong>ï¼šç”¨ LLM æŠŠæ—§å¯¹è¯å‹ç¼©æˆ summary</li>
      <li><strong>æ»‘åŠ¨çª—å£</strong>ï¼šåªä¿ç•™æœ€è¿‘ K æ¡</li>
      <li><strong>RAG æ£€ç´¢</strong>ï¼šæ—§å†…å®¹å­˜å‘é‡åº“ï¼Œéœ€è¦æ—¶æ£€ç´¢</li>
      <li><strong>åˆ†å±‚å­˜å‚¨</strong>ï¼šHot (recent) â†’ Warm (summary) â†’ Cold (vector)</li>
      <li><strong>æƒè¡¡è®¨è®º</strong>ï¼šæˆæœ¬ vs è´¨é‡ vs å»¶è¿Ÿ</li>
    </ol>
  </div>

  <div class="interview">
    <h4>Q3: Short-term vs Long-term Memory çš„æƒè¡¡ï¼Ÿ</h4>
    <table>
      <tr>
        <th>ç»´åº¦</th><th>Short-term</th><th>Long-term</th>
      </tr>
      <tr>
        <td>èŒƒå›´</td><td>å½“å‰ session</td><td>è·¨ session</td>
      </tr>
      <tr>
        <td>è®¿é—®é€Ÿåº¦</td><td>O(1) ç›´æ¥åœ¨ prompt</td><td>O(log n) éœ€è¦æ£€ç´¢</td>
      </tr>
      <tr>
        <td>å‡†ç¡®æ€§</td><td>é«˜ï¼ˆåŸæ–‡ï¼‰</td><td>ä¸­ï¼ˆå¯èƒ½æ£€ç´¢ä¸å‡†ï¼‰</td>
      </tr>
      <tr>
        <td>æˆæœ¬</td><td>æ¯æ¬¡éƒ½ä»˜ token</td><td>åªåœ¨æ£€ç´¢æ—¶ä»˜</td>
      </tr>
      <tr>
        <td>å®ç°å¤æ‚åº¦</td><td>ä½</td><td>é«˜ï¼ˆéœ€è¦ embedding + å‘é‡åº“ï¼‰</td>
      </tr>
    </table>
  </div>

  <h2>âœ… å¯å­¦ä¹ çš„ Patterns</h2>
  
  <div class="pattern">
    <h4>1. Token Budget ç®¡ç†</h4>
    <p>æ°¸è¿œç»™ memory è®¾å®š token é¢„ç®—ï¼ŒæŒ‰ä¼˜å…ˆçº§åˆ†é…ï¼š</p>
    <pre><code>const MEMORY_BUDGET = 4000; // tokens
const allocation = {
  entities: 0.1,      // 400 tokens
  retrieved: 0.3,     // 1200 tokens  
  summary: 0.15,      // 600 tokens
  recentWindow: 0.45  // 1800 tokens
};</code></pre>
  </div>

  <div class="pattern">
    <h4>2. å†·çƒ­åˆ†ç¦»</h4>
    <p>åƒ CPU ç¼“å­˜ä¸€æ ·è®¾è®¡ memory å±‚æ¬¡ï¼š</p>
    <ul>
      <li><strong>L1 (Hot)</strong>: æœ€è¿‘ 5 æ¡æ¶ˆæ¯ - åœ¨ prompt é‡Œ</li>
      <li><strong>L2 (Warm)</strong>: Summary - å‹ç¼©ååœ¨ prompt é‡Œ</li>
      <li><strong>L3 (Cold)</strong>: Vector Store - æŒ‰éœ€æ£€ç´¢</li>
    </ul>
  </div>

  <div class="pattern">
    <h4>3. å®ä½“æå–æ—¶æœº</h4>
    <p>ä¸è¦æ¯æ¡æ¶ˆæ¯éƒ½æå–å®ä½“ï¼ˆæˆæœ¬é«˜ï¼‰ï¼Œå»ºè®®ï¼š</p>
    <ul>
      <li>Session ç»“æŸæ—¶æ‰¹é‡æå–</li>
      <li>æˆ–æ£€æµ‹åˆ°ç‰¹å®š pattern æ—¶æå–ï¼ˆ"æˆ‘å«..."ã€"æˆ‘å–œæ¬¢..."ï¼‰</li>
    </ul>
  </div>

  <h2>ğŸ”— OpenClaw ä¸­çš„ Memory å®è·µ</h2>
  
  <div class="highlight-blue">
    <p>OpenClaw (ä¹Ÿå°±æ˜¯æˆ‘) ä½¿ç”¨çš„ memory æœºåˆ¶ï¼š</p>
    <ul>
      <li><strong>MEMORY.md</strong> - Entity Memory çš„æ–‡ä»¶å®ç°ï¼Œæ‰‹åŠ¨ç»´æŠ¤å…³é”®ä¿¡æ¯</li>
      <li><strong>memory/YYYY-MM-DD.md</strong> - æ—¥å¿—å¼çš„ episodic memory</li>
      <li><strong>Conversation context</strong> - ç”± Gateway ç®¡ç†çš„ short-term memory</li>
      <li><strong>memory_search</strong> - è¯­ä¹‰æ£€ç´¢å·¥å…·ï¼Œå®ç° vector memory æ•ˆæœ</li>
    </ul>
    <p>è¿™æ˜¯ä¸€ä¸ª<strong>æ–‡ä»¶ä¼˜å…ˆ</strong>çš„ memory è®¾è®¡ï¼Œç®€å•ä½†æœ‰æ•ˆï¼</p>
  </div>

  <div class="follow-up">
    <h3>ğŸ’¬ åç»­è®¨è®º / Follow-up Discussion</h3>
    <p>æƒ³æ·±å…¥äº†è§£å“ªä¸ªæ–¹é¢ï¼Ÿ</p>
    <ul>
      <li>å…·ä½“å‘é‡æ•°æ®åº“é€‰å‹ï¼ˆPinecone vs Chroma vs pgvectorï¼‰</li>
      <li>Memory çš„éšç§å’Œå®‰å…¨è®¾è®¡</li>
      <li>å¦‚ä½•è¯„ä¼° memory ç³»ç»Ÿçš„æ•ˆæœ</li>
      <li>å®ç°ä¸€ä¸ªå®Œæ•´çš„ memory ç³»ç»Ÿ demo</li>
    </ul>
  </div>

  <hr>
  <p style="color: #666; font-size: 0.9em;">
    ğŸ“š ç³»åˆ—æ–‡ç« ï¼š<a href="2026-02-01-react-pattern-tool-use.html">ReAct & Tool Use</a> â†’ 
    <a href="2026-02-02-multi-agent-collaboration.html">Multi-Agent åä½œ</a> â†’ 
    <strong>Agent Memory</strong> â†’ 
    Next: RAG ç³»ç»Ÿè®¾è®¡
  </p>
</body>
</html>
