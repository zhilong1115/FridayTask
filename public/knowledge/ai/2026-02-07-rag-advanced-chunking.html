<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>2026-02-07 - RAG Advanced Chunking Strategies</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background: #fafafa; }
    .bilingual { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    .zh { border-left: 3px solid #f9ab00; padding-left: 15px; }
    .en { border-left: 3px solid #1a73e8; padding-left: 15px; }
    h1 { color: #3c4043; }
    h2 { color: #5f6368; border-bottom: 1px solid #dadce0; padding-bottom: 8px; }
    .architecture { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; }
    pre { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 13px; }
    code { font-family: 'SF Mono', Consolas, monospace; }
    .highlight { background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .highlight-blue { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .highlight-green { background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .diagram { background: #263238; color: #aed581; padding: 20px; border-radius: 8px; font-family: monospace; white-space: pre; margin: 20px 0; font-size: 12px; overflow-x: auto; }
    .comparison { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0; }
    .comparison > div { background: white; padding: 15px; border-radius: 8px; border: 1px solid #dadce0; }
    .comparison h4 { margin-top: 0; color: #1a73e8; }
    .interview { background: #fce4ec; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #e91e63; }
    .interview h3 { margin-top: 0; color: #c2185b; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { border: 1px solid #dadce0; padding: 10px; text-align: left; }
    th { background: #f8f9fa; }
    .series-nav { background: #e8eaf6; padding: 10px 15px; border-radius: 8px; margin-bottom: 20px; }
    .tag { display: inline-block; background: #1a73e8; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px; }
  </style>
</head>
<body>
  <div class="series-nav">
    ğŸ“š <strong>RAG System Design ç³»åˆ—</strong> | Day 2 of 4 | 
    <a href="2026-02-05-rag-pipeline-architecture.html">â† Day 1: Pipeline æ¶æ„</a> | 
    Day 3: Advanced Retrieval â†’
  </div>

  <h1>ğŸ§© RAG Advanced Chunking Strategies</h1>
  <p><span class="tag">RAG</span> <span class="tag">é¢è¯•é‡ç‚¹</span> <span class="tag">å®æˆ˜</span></p>
  <p>ğŸ“… 2026-02-07 | Phase 1.3 RAG ç³»ç»Ÿè®¾è®¡</p>

  <h2>ğŸ“– ä»Šæ—¥ä¸»é¢˜ / Today's Topic</h2>
  <div class="bilingual">
    <div class="zh">
      <p>æ˜¨å¤©è®²äº† RAG Pipeline æ•´ä½“æ¶æ„ï¼Œä»Šå¤©æ·±å…¥ <strong>Chunking ç­–ç•¥</strong> â€” è¿™æ˜¯å½±å“ RAG è´¨é‡çš„æœ€å¤§æ æ†ä¹‹ä¸€ã€‚</p>
      <p>æ ¸å¿ƒçŸ›ç›¾ï¼š<strong>å° chunk åŒ¹é…ç²¾å‡†ä½†ä¸¢å¤±ä¸Šä¸‹æ–‡ï¼Œå¤§ chunk ä¿ç•™ä¸Šä¸‹æ–‡ä½†ç¨€é‡Šç›¸å…³æ€§</strong>ã€‚ä»Šå¤©ä»‹ç»ä¸‰ç§é«˜çº§ç­–ç•¥æ¥è§£å†³è¿™ä¸ªçŸ›ç›¾ã€‚</p>
    </div>
    <div class="en">
      <p>Yesterday we covered RAG Pipeline architecture. Today we dive into <strong>Chunking Strategies</strong> â€” one of the biggest levers for RAG quality.</p>
      <p>Core trade-off: <strong>Small chunks match precisely but lose context; large chunks preserve context but dilute relevance</strong>. Today's strategies solve this.</p>
    </div>
  </div>

  <h2>ğŸ—ï¸ ä¸‰å¤§é«˜çº§ç­–ç•¥å¯¹æ¯” / Strategy Comparison</h2>
  
  <div class="comparison">
    <div>
      <h4>1ï¸âƒ£ Semantic Chunking</h4>
      <p><strong>åŸç†</strong>: ç”¨ embedding ç›¸ä¼¼åº¦æ‰¾è‡ªç„¶æ–­ç‚¹</p>
      <p><strong>ä¼˜ç‚¹</strong>: è¯­ä¹‰å®Œæ•´æ€§æœ€å¥½</p>
      <p><strong>ç¼ºç‚¹</strong>: éœ€è¦é¢å¤– embedding è°ƒç”¨</p>
      <p><strong>é€‚ç”¨</strong>: é•¿æ–‡æœ¬ã€è®ºæ–‡ã€æŠ€æœ¯æ–‡æ¡£</p>
    </div>
    <div>
      <h4>2ï¸âƒ£ Parent-Child Chunking</h4>
      <p><strong>åŸç†</strong>: å° chunk ç´¢å¼•ï¼Œå¤§ chunk è¿”å›</p>
      <p><strong>ä¼˜ç‚¹</strong>: åŒæ—¶è·å¾—ç²¾å‡†åŒ¹é…å’Œå®Œæ•´ä¸Šä¸‹æ–‡</p>
      <p><strong>ç¼ºç‚¹</strong>: éœ€è¦é¢å¤–å­˜å‚¨å±‚</p>
      <p><strong>é€‚ç”¨</strong>: éœ€è¦ä¸Šä¸‹æ–‡çš„é—®ç­”ç³»ç»Ÿ</p>
    </div>
    <div>
      <h4>3ï¸âƒ£ Agentic Chunking</h4>
      <p><strong>åŸç†</strong>: LLM æ™ºèƒ½åˆ†ææ–‡æ¡£ç»“æ„</p>
      <p><strong>ä¼˜ç‚¹</strong>: æœ€æ™ºèƒ½ï¼Œå¤„ç†å¤æ‚æ ¼å¼</p>
      <p><strong>ç¼ºç‚¹</strong>: æˆæœ¬é«˜ã€é€Ÿåº¦æ…¢</p>
      <p><strong>é€‚ç”¨</strong>: é«˜ä»·å€¼æ–‡æ¡£ã€å¤æ‚ PDF</p>
    </div>
  </div>

  <h2>1ï¸âƒ£ Semantic Chunking è¯­ä¹‰åˆ†å—</h2>
  
  <div class="bilingual">
    <div class="zh">
      <p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šä¸æŒ‰å­—ç¬¦æ•°åˆ‡ï¼Œè€Œæ˜¯æ‰¾è¯­ä¹‰çš„è‡ªç„¶æ–­ç‚¹ã€‚</p>
      <p>æ–¹æ³•ï¼šè®¡ç®—ç›¸é‚»å¥å­çš„ embedding ç›¸ä¼¼åº¦ï¼Œç›¸ä¼¼åº¦çªç„¶ä¸‹é™çš„åœ°æ–¹å°±æ˜¯æ–­ç‚¹ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Core idea</strong>: Don't split by character count. Find natural semantic boundaries.</p>
      <p>Method: Calculate embedding similarity between adjacent sentences. Where similarity drops sharply = split point.</p>
    </div>
  </div>

  <div class="diagram">
Sentence Embeddings:     Similarity Score:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sentence 1      â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ 0.92 (high) â”€â†’ same chunk
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Sentence 2      â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”
                     â”‚ 0.45 (low) â”€â”€â†’ âœ‚ï¸ SPLIT HERE!
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Sentence 3      â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”
                     â”‚ 0.88 (high) â”€â†’ same chunk
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Sentence 4      â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  </div>

  <div class="highlight">
    <h4>ğŸ’¡ å…³é”®å‚æ•°: breakpoint_threshold</h4>
    <p>â€¢ <strong>Percentile (æ¨è)</strong>: ç”¨ç›¸ä¼¼åº¦åˆ†å¸ƒçš„æŸä¸ªç™¾åˆ†ä½ä½œä¸ºé˜ˆå€¼ (å¦‚ 95th percentile)</p>
    <p>â€¢ <strong>Standard Deviation</strong>: å‡å€¼ - N ä¸ªæ ‡å‡†å·®ä½œä¸ºé˜ˆå€¼</p>
    <p>â€¢ <strong>Interquartile</strong>: ç”¨ IQR æ–¹æ³•æ£€æµ‹å¼‚å¸¸ä½çš„ç›¸ä¼¼åº¦</p>
  </div>

  <h3>ğŸ’» å®ç°ä»£ç  / Implementation</h3>
  <pre><code>from langchain_experimental.text_splitter import SemanticChunker
from langchain_openai import OpenAIEmbeddings

# åˆå§‹åŒ– semantic chunker
chunker = SemanticChunker(
    embeddings=OpenAIEmbeddings(),
    breakpoint_threshold_type="percentile",  # æ¨è
    breakpoint_threshold_amount=95,  # 95th percentile
)

# åˆ‡åˆ†æ–‡æ¡£
chunks = chunker.split_text(long_document)

# æˆ–è€…ç”¨ chonkie åº“ (æ›´è½»é‡)
from chonkie import SemanticChunker

chunker = SemanticChunker(
    embedding_model="text-embedding-3-small",
    chunk_size=512,
    similarity_threshold=0.5,
)
chunks = chunker.chunk(text)</code></pre>

  <div class="highlight-blue">
    <h4>ğŸ“Š æ€§èƒ½æ•°æ® (NVIDIA 2024 Benchmark)</h4>
    <p>â€¢ Semantic chunking vs Recursive: <strong>+2-3% recall</strong> æå‡</p>
    <p>â€¢ ä½†éœ€è¦ <strong>é¢å¤– embedding è°ƒç”¨</strong> (æˆæœ¬å¢åŠ )</p>
    <p>â€¢ é€‚åˆï¼šé•¿æ–‡æœ¬ã€ä¸»é¢˜åˆ‡æ¢é¢‘ç¹çš„æ–‡æ¡£</p>
  </div>

  <h2>2ï¸âƒ£ Parent-Child Chunking çˆ¶å­åˆ†å—</h2>
  
  <div class="bilingual">
    <div class="zh">
      <p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šé±¼å’Œç†ŠæŒå…¼å¾—ï¼</p>
      <ul>
        <li><strong>Child chunks (å°)</strong>: ç”¨äºå‘é‡ç´¢å¼•å’ŒåŒ¹é… (400 tokens)</li>
        <li><strong>Parent chunks (å¤§)</strong>: åŒ¹é…åè¿”å›ç»™ LLM (2000 tokens)</li>
      </ul>
      <p>åŒ¹é…ç”¨å° chunk ä¿è¯ç²¾å‡†ï¼Œè¿”å›ç”¨å¤§ chunk ä¿è¯ä¸Šä¸‹æ–‡ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Core idea</strong>: Best of both worlds!</p>
      <ul>
        <li><strong>Child chunks (small)</strong>: Used for vector indexing (400 tokens)</li>
        <li><strong>Parent chunks (large)</strong>: Returned to LLM (2000 tokens)</li>
      </ul>
      <p>Match with small chunks for precision, return large chunks for context.</p>
    </div>
  </div>

  <div class="diagram">
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚           Parent Document               â”‚
                    â”‚              (2000 tokens)              â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”  â”‚
                    â”‚  â”‚ Child 1 â”‚ Child 2 â”‚ Child 3 â”‚ ... â”‚  â”‚
                    â”‚  â”‚ (400)   â”‚ (400)   â”‚ (400)   â”‚     â”‚  â”‚
                    â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚         â”‚         â”‚
                            â–¼         â–¼         â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        Vector Store (ç´¢å¼•)         â”‚
                    â”‚   Embed children, store IDs       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    Query: "What is X?" â”€â”€â–¶ Match Child 2
                                      â”‚
                                      â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        Document Store             â”‚
                    â”‚   Child 2 ID â”€â”€â–¶ Parent Doc       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                           Return: Full Parent (2000 tokens)
  </div>

  <h3>ğŸ’» LangChain å®ç° / Implementation</h3>
  <pre><code>from langchain.retrievers import ParentDocumentRetriever
from langchain.storage import InMemoryStore
from langchain_chroma import Chroma
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_openai import OpenAIEmbeddings

# çˆ¶çº§åˆ‡åˆ†å™¨ (å¤§ chunks)
parent_splitter = RecursiveCharacterTextSplitter(
    chunk_size=2000,
    chunk_overlap=200,
)

# å­çº§åˆ‡åˆ†å™¨ (å° chunks)
child_splitter = RecursiveCharacterTextSplitter(
    chunk_size=400,
    chunk_overlap=50,
)

# Vector store åªç´¢å¼• children
vectorstore = Chroma(
    collection_name="children",
    embedding_function=OpenAIEmbeddings(),
)

# Document store å­˜å‚¨ parents
docstore = InMemoryStore()  # ç”Ÿäº§ç¯å¢ƒç”¨ Redis/MongoDB

# åˆ›å»º retriever
retriever = ParentDocumentRetriever(
    vectorstore=vectorstore,
    docstore=docstore,
    child_splitter=child_splitter,
    parent_splitter=parent_splitter,  # å¯é€‰
)

# æ·»åŠ æ–‡æ¡£ (è‡ªåŠ¨å¤„ç†çˆ¶å­å…³ç³»)
retriever.add_documents(documents)

# æ£€ç´¢ (è¿”å› parent documents!)
results = retriever.invoke("What is RAG?")</code></pre>

  <div class="highlight-green">
    <h4>âœ… ä¸ºä»€ä¹ˆè¿™ä¸ªè®¾è®¡å¥½</h4>
    <p><strong>1. è§£å†³æ ¸å¿ƒçŸ›ç›¾</strong>: å° chunk åŒ¹é… + å¤§ chunk ä¸Šä¸‹æ–‡</p>
    <p><strong>2. å­˜å‚¨å¼€é”€å¯æ§</strong>: Parents å­˜ä¸€æ¬¡ï¼Œchildren åªå­˜ ID æ˜ å°„</p>
    <p><strong>3. çµæ´»æ€§é«˜</strong>: å¯ä»¥è°ƒæ•´ parent/child æ¯”ä¾‹</p>
    <p><strong>4. ç”Ÿäº§éªŒè¯</strong>: è¢«å¹¿æ³›ç”¨äºä¼ä¸š RAG ç³»ç»Ÿ</p>
  </div>

  <h2>3ï¸âƒ£ Agentic Chunking LLM æ™ºèƒ½åˆ†å—</h2>
  
  <div class="bilingual">
    <div class="zh">
      <p><strong>æ ¸å¿ƒæ€æƒ³</strong>ï¼šè®© LLM æ¥å†³å®šæ€ä¹ˆåˆ‡ï¼</p>
      <p>æŠŠæ–‡æ¡£æ‰”ç»™ LLMï¼Œè®©å®ƒåˆ†æç»“æ„å¹¶è¾“å‡ºæœ€ä¼˜åˆ†å—æ–¹æ¡ˆã€‚</p>
      <p>é€‚åˆï¼šå¤æ‚ PDFã€æ··åˆæ ¼å¼æ–‡æ¡£ã€é«˜ä»·å€¼å†…å®¹ã€‚</p>
    </div>
    <div class="en">
      <p><strong>Core idea</strong>: Let the LLM decide how to chunk!</p>
      <p>Send document to LLM, have it analyze structure and output optimal chunking.</p>
      <p>Best for: Complex PDFs, mixed-format docs, high-value content.</p>
    </div>
  </div>

  <h3>ğŸ’» å®ç°æ€è·¯ / Implementation</h3>
  <pre><code>import openai

def agentic_chunk(document: str) -> list[str]:
    """Use LLM to intelligently chunk document"""
    
    prompt = """Analyze this document and split it into semantic chunks.
    
Rules:
1. Each chunk should be self-contained and coherent
2. Preserve tables and code blocks as single chunks
3. Keep related paragraphs together
4. Target 300-500 words per chunk
5. Output as JSON array of strings

Document:
{document}

Output format: ["chunk1...", "chunk2...", ...]"""

    response = openai.chat.completions.create(
        model="gpt-4o-mini",  # ç”¨ä¾¿å®œçš„æ¨¡å‹
        messages=[{"role": "user", "content": prompt.format(document=document)}],
        response_format={"type": "json_object"},
    )
    
    return json.loads(response.choices[0].message.content)["chunks"]</code></pre>

  <div class="highlight">
    <h4>âš ï¸ æˆæœ¬ vs è´¨é‡æƒè¡¡</h4>
    <table>
      <tr>
        <th>ç­–ç•¥</th>
        <th>æˆæœ¬</th>
        <th>è´¨é‡</th>
        <th>é€‚ç”¨åœºæ™¯</th>
      </tr>
      <tr>
        <td>Fixed/Recursive</td>
        <td>$0</td>
        <td>â˜…â˜…â˜…â˜†â˜†</td>
        <td>å¤§é‡æ–‡æ¡£ã€é¢„ç®—æœ‰é™</td>
      </tr>
      <tr>
        <td>Semantic</td>
        <td>~$0.001/doc</td>
        <td>â˜…â˜…â˜…â˜…â˜†</td>
        <td>é•¿æ–‡æ¡£ã€ä¸»é¢˜å¤šå˜</td>
      </tr>
      <tr>
        <td>Agentic (GPT-4o-mini)</td>
        <td>~$0.01/doc</td>
        <td>â˜…â˜…â˜…â˜…â˜…</td>
        <td>é«˜ä»·å€¼æ–‡æ¡£ã€å¤æ‚æ ¼å¼</td>
      </tr>
    </table>
  </div>

  <h2>ğŸ“š å®æˆ˜å»ºè®® / Practical Guidelines</h2>
  
  <div class="highlight-blue">
    <h4>ğŸ¯ é€‰æ‹©ç­–ç•¥çš„å†³ç­–æ ‘</h4>
    <pre>
æ–‡æ¡£é‡å¤§ (>10k docs)?
â”œâ”€ Yes â”€â”€â–¶ Recursive Splitting (æˆæœ¬ä¼˜å…ˆ)
â””â”€ No
    â”œâ”€ æ–‡æ¡£ç»“æ„å¤æ‚ (PDF/è¡¨æ ¼)?
    â”‚   â””â”€ Yes â”€â”€â–¶ Agentic Chunking
    â”‚
    â”œâ”€ éœ€è¦ç²¾å‡†åŒ¹é… + å®Œæ•´ä¸Šä¸‹æ–‡?
    â”‚   â””â”€ Yes â”€â”€â–¶ Parent-Child
    â”‚
    â””â”€ æ–‡æ¡£é•¿ã€ä¸»é¢˜å¤š?
        â””â”€ Yes â”€â”€â–¶ Semantic Chunking
    </pre>
  </div>

  <div class="highlight-green">
    <h4>ğŸ’¡ ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ</h4>
    <p><strong>1. ç»„åˆä½¿ç”¨</strong>: Parent-Child + Semantic å¯ä»¥å åŠ </p>
    <p><strong>2. Chunk Overlap</strong>: ä¿æŒ 10-15% overlap é˜²æ­¢æ–­å¥</p>
    <p><strong>3. Metadata ä¿ç•™</strong>: å§‹ç»ˆä¿å­˜ source, page, section ç­‰å…ƒæ•°æ®</p>
    <p><strong>4. å®éªŒé©±åŠ¨</strong>: ç”¨ä½ çš„å®é™…æ•°æ®æµ‹è¯•ä¸åŒç­–ç•¥ï¼</p>
  </div>

  <h2>ğŸ¤ é¢è¯•é¢˜ / Interview Questions</h2>
  
  <div class="interview">
    <h3>Q1: ä¸ºä»€ä¹ˆéœ€è¦ Chunkingï¼Ÿç›´æ¥ç”¨æ•´ä¸ªæ–‡æ¡£ä¸è¡Œå—ï¼Ÿ</h3>
    <p><strong>ç­”</strong>: ä¸‰ä¸ªåŸå› ï¼š</p>
    <ol>
      <li><strong>Token é™åˆ¶</strong>: LLM æœ‰ context window é™åˆ¶</li>
      <li><strong>æ£€ç´¢ç²¾åº¦</strong>: æ•´ä¸ªæ–‡æ¡£ embedding ä¼šç¨€é‡Šå…³é”®ä¿¡æ¯</li>
      <li><strong>æˆæœ¬</strong>: å¡å…¥è¿‡é•¿ä¸Šä¸‹æ–‡æµªè´¹ token</li>
    </ol>
    <p><strong>ä½†æ³¨æ„</strong>: çŸ­æ–‡æ¡£ (FAQã€äº§å“æè¿°) ä¸ä¸€å®šéœ€è¦ chunkingï¼</p>
  </div>

  <div class="interview">
    <h3>Q2: Parent-Child Retriever çš„ä¸¤ä¸ª store åˆ†åˆ«å­˜ä»€ä¹ˆï¼Ÿ</h3>
    <p><strong>ç­”</strong>:</p>
    <ul>
      <li><strong>Vector Store</strong>: å­˜ child chunks çš„ embeddingsï¼Œç”¨äºæ£€ç´¢</li>
      <li><strong>Document Store</strong>: å­˜ parent documents çš„åŸæ–‡ï¼Œé€šè¿‡ ID å…³è”</li>
    </ul>
    <p>æ£€ç´¢æ—¶ï¼šquery â†’ match child â†’ lookup parent ID â†’ return parent content</p>
  </div>

  <div class="interview">
    <h3>Q3: Semantic Chunking çš„ breakpoint threshold æ€ä¹ˆé€‰ï¼Ÿ</h3>
    <p><strong>ç­”</strong>: æ¨èç”¨ <strong>percentile æ–¹æ³•</strong> (å¦‚ 95th)ï¼Œå› ä¸ºï¼š</p>
    <ul>
      <li>è‡ªé€‚åº”ä¸åŒæ–‡æ¡£çš„ç›¸ä¼¼åº¦åˆ†å¸ƒ</li>
      <li>ä¸éœ€è¦æ‰‹åŠ¨è°ƒå‚</li>
      <li>æ¯”å›ºå®šé˜ˆå€¼æ›´é²æ£’</li>
    </ul>
  </div>

  <div class="interview">
    <h3>Q4: ä»€ä¹ˆæ—¶å€™ç”¨ Agentic Chunkingï¼Ÿ</h3>
    <p><strong>ç­”</strong>: é«˜ä»·å€¼ + ç»“æ„å¤æ‚çš„åœºæ™¯ï¼š</p>
    <ul>
      <li>æ³•å¾‹åˆåŒ (éœ€è¦ä¿æŒæ¡æ¬¾å®Œæ•´)</li>
      <li>è´¢æŠ¥ PDF (è¡¨æ ¼ + æ–‡å­—æ··åˆ)</li>
      <li>æŠ€æœ¯æ‰‹å†Œ (ä»£ç  + è¯´æ˜)</li>
    </ul>
    <p>æˆæœ¬é«˜ï¼Œä½†è¿™äº›åœºæ™¯ä¸‹è´¨é‡æ›´é‡è¦ã€‚</p>
  </div>

  <h2>ğŸ”— Day 2 æ€»ç»“</h2>
  
  <table>
    <tr>
      <th>ç­–ç•¥</th>
      <th>æ ¸å¿ƒæ€æƒ³</th>
      <th>é€‚ç”¨åœºæ™¯</th>
    </tr>
    <tr>
      <td>Semantic</td>
      <td>embedding ç›¸ä¼¼åº¦æ‰¾æ–­ç‚¹</td>
      <td>é•¿æ–‡æœ¬ã€ä¸»é¢˜å¤šå˜</td>
    </tr>
    <tr>
      <td>Parent-Child</td>
      <td>å° chunk åŒ¹é…ï¼Œå¤§ chunk è¿”å›</td>
      <td>éœ€è¦ä¸Šä¸‹æ–‡çš„é—®ç­”</td>
    </tr>
    <tr>
      <td>Agentic</td>
      <td>LLM æ™ºèƒ½åˆ†æç»“æ„</td>
      <td>é«˜ä»·å€¼å¤æ‚æ–‡æ¡£</td>
    </tr>
  </table>

  <p><strong>æ˜å¤© Day 3</strong>: Advanced Retrieval â€” Query Transform, Self-Query, Multi-hop Retrieval ğŸš€</p>

  <div class="series-nav" style="margin-top: 30px;">
    ğŸ“š <strong>RAG ç³»åˆ—è¿›åº¦</strong>: 
    âœ… Day 1 Pipeline | 
    âœ… Day 2 Chunking | 
    â¬œ Day 3 Retrieval | 
    â¬œ Day 4 Production
  </div>

</body>
</html>
